<?php

/**
 * Core
 *
 * A modular class collection for rapid application development.
 *
 * @package core
 * @author Stefano Azzolini <lastguest@gmail.com>
 * @repository git@github.com:coesion/core.git
 * @license MIT (LICENSE.md)
 * @copyright Coesion - 2026
 */
// Coesion Core artifact metadata: {"generator":"tools/build-core.php","source":"git@github.com:coesion/core.git","commit":"2ac499846c1e","version":"1.3.2"}
namespace {if (defined('COESION_CORE_LOADED')) { return; } define('COESION_CORE_LOADED', true);class API { public static function resource($path, array $options){ $options = array_replace_recursive([ "class" => null, "list_mode" => "list", "sql" => [ "table" => null, "raw" => null, "primary_key" => "id", ], ], $options); $path = rtrim($path,"/") ?: "/"; $resource = $options["class"]; $table = $options["sql"]["table"]; $raw = $options["sql"]["raw"]; $pkey = $options["sql"]["primary_key"]; $sql_list = $raw ?: "SELECT * FROM $table"; $sql_single = strpos($sql_list, "WHERE")===false ? "$sql_list WHERE $pkey=:$pkey" : str_replace("WHERE ","WHERE $pkey=:$pkey AND ",$sql_list); $sql_single .= " LIMIT 1"; if (class_exists($resource, false) && ($table || $raw) && $pkey ) { Route::on($path, function() use ($resource, $table, $sql_list, $options) { $resource::setExposure($options["list_mode"]); return $resource::fromSQL($sql_list); }); Route::on("$path/:id", function($id) use ($resource, $table, $pkey, $sql_single) { return ['data' => ($resource::singleFromSQL($sql_single,["$pkey"=>$id]) ?: API::error("Not found",404))]; }); Route::on("$path/:id/:parameter", function($id, $parameter) use ($resource, $table, $pkey, $sql_single) { Filter::add("api.$resource.getProjectionFields", function($t) use ($parameter){ return $parameter; }); return ['data' => ($resource::singleFromSQL($sql_single,["$pkey"=>$id]) ?: API::error("Not found",404))]; }); } } public static function error($message, $status=501){ Event::trigger('api.error',[$message,$status]); Response::status($status); Response::json([ 'error' => [ 'type' => 'fatal', 'status' => $status, 'message' => $message, ], ]); Response::send(); exit; } }class Collection { public static function fromSQL($resource, $sql, $params=[]){ $count = SQL::value(preg_replace( [ '(SELECT(.+)FROM)i', '(LIMIT\s+\d+\s+)i', '(OFFSET\s+\d+\s+)i' ], [ 'SELECT COUNT(1) FROM', '', '', ], $sql.' '), $params, 0); $page = Filter::with(["api.$resource.page", "api.page"], max(1,Request::get('page',1))); $limit = Filter::with(["api.$resource.limit", "api.limit"], max(1,Request::get('limit',10))); $page = min($page, ceil($count/$limit)); $offset = max(0, $page-1); $sql = "$sql LIMIT $limit OFFSET $offset"; return static::wrap( $resource, SQL::each($sql, $params), $page, $limit, $count ); } public static function wrap($resource, $data, $page, $limit, $count){ if (!class_exists($resource)) throw new Exception("[API] Resource class $resource doesn't exists", 1); $projector = $resource::buildProjector(); return [ "data" => array_map(function($e) use ($resource, $projector){ return new $resource($e, $projector); }, $data), "pagination" => [ "page" => $page, "limit" => $limit, "count" => $count, ] ]; } }class Core { public const VERSION = '1.3.2'; public static function version(){ return self::VERSION; } public static function diagnostics(){ $opcache = function_exists('opcache_get_status') ? opcache_get_status(false) : false; $opcacheConfig = function_exists('opcache_get_configuration') ? opcache_get_configuration() : false; return [ 'version' => self::VERSION, 'php' => PHP_VERSION, 'sapi' => PHP_SAPI, 'extensions' => get_loaded_extensions(), 'opcache' => $opcache, 'opcache_config' => $opcacheConfig, 'preload' => ini_get('opcache.preload') ?: '', ]; } public static function log($level, $message, array $context = []){ Event::trigger('core.log', $level, $message, $context); } } \Core\Aliases::register();class Deferred { protected $callback, $enabled = true; public function __construct( callable $callback ) { $this->callback = $callback; } public function disarm() { $this->enabled = false; } public function prime() { $this->enabled = true; } public function __destruct() { if ( $this->enabled ) call_user_func( $this->callback ); } }trait Events { protected static $_listeners = []; public static function on($name,callable $listener){ static::$_listeners[$name][] = $listener; } public static function onSingle($name,callable $listener){ static::$_listeners[$name] = [$listener]; } public static function off($name, ?callable $listener = null){ if($listener === null) { unset(static::$_listeners[$name]); } else { if ($idx = array_search($listener,static::$_listeners[$name],true)) unset(static::$_listeners[$name][$idx]); } } public static function alias($source,$alias){ static::$_listeners[$alias] =& static::$_listeners[$source]; } public static function trigger($name, ...$args){ if (false === empty(static::$_listeners[$name])){ $results = []; foreach (static::$_listeners[$name] as $listener) { $results[] = $listener(...$args); } return $results; }; } public static function triggerOnce($name){ $res = static::trigger($name); unset(static::$_listeners[$name]); return $res; } }trait Filters { protected static $_modders = []; public static function filter($names, ?callable $modder = null){ if( null === $modder ) foreach ( (array)$names as $name => $callback ) { static::$_modders[$name][] = $callback; } else foreach ( (array)$names as $name ) { static::$_modders[$name][] = $modder; } } public static function filterSingle($name, callable $modder){ static::$_modders[$name] = [$modder]; } public static function filterRemove($name, ?callable $modder = null){ if($modder === null) { unset(static::$_modders[$name]); } else { if ($idx = array_search($modder,static::$_modders[$name],true)) unset(static::$_modders[$name][$idx]); } } public static function filterWith($names, $default, ...$args){ foreach ((array)$names as $name) { if (!empty(static::$_modders[$name])) { $value = $default; foreach (static::$_modders[$name] as $modder) { $value = $modder($value, $args); } return $value; } } return $default; } }abstract class Dictionary { use Events; use Filters; protected static $fields = null; public static function & all(){ if (!static::$fields) static::$fields = new Map(); return static::$fields->all(); } public static function get($key, $default=null){ if (!static::$fields) static::$fields = new Map(); if (is_array($key)){ $results = []; foreach ($key as $_dst_key => $_src_key) $results[$_dst_key] = static::$fields->get($_src_key); return $results; } else { return static::$fields->get($key, $default); } } public static function set($key, $value=null){ if (!static::$fields) static::$fields = new Map(); return static::$fields->set($key, $value); } public static function delete($key, $compact=true){ if (!static::$fields) static::$fields = new Map(); static::$fields->delete($key, $compact); } public static function exists($key){ if (!static::$fields) static::$fields = new Map(); return static::$fields->exists($key); } public static function clear(){ if (!static::$fields) static::$fields = new Map(); static::$fields->clear(); } public static function load($fields){ if (!static::$fields) static::$fields = new Map(); static::$fields->load($fields); } public static function merge(array $array, $merge_back=false){ if (!static::$fields) static::$fields = new Map(); static::$fields->merge($array, $merge_back); } protected static function compact(){ if (!static::$fields) static::$fields = new Map(); static::$fields->compact(); } protected static function & find($path, $create=false, ?callable $operation=null) { return static::$fields->find($path, $create, $operation); } public function jsonSerialize(): mixed { if (!static::$fields) static::$fields = new Map(); return static::$fields->jsonSerialize(); } }class Loader { protected static $paths = []; public static function addPath($path,$name=null){ static::$paths[$path] = $name; } public static function register(){ if (ini_get('unserialize_callback_func') !== false) { ini_set('unserialize_callback_func', 'spl_autoload_call'); } spl_autoload_register(callback: function($class){ $normalized = strtr($class, '\\', '/'); $candidates = [$normalized . '.php']; if (strpos($normalized, '_') !== false) { $candidates[] = strtr($normalized, '_', '/') . '.php'; } foreach (static::$paths as $path => $v) { $base = rtrim($path, '/'); foreach ($candidates as $candidate) { $file = $base . '/' . $candidate; if (is_file($file)) return include($file); } } return false; }); } } Loader::addPath(__DIR__); Loader::register();class Map implements JsonSerializable { protected $fields = []; public function & all(){ return $this->fields; } public function get($key, $default=null){ if (null !== ($ptr =& $this->find($key,false))){ return $ptr; } else { if ($default !== null){ return $this->set($key, is_callable($default) ? call_user_func($default) : $default); } else { return null; } } } public function set($key, $value=null){ if (is_array($key)) { return $this->merge($key); } else { $ptr =& $this->find($key, true); return $ptr = $value; } } public function delete($key, $compact=true){ $this->set($key, null); if ($compact) $this->compact(); } public function exists($key){ return null !== $this->find($key, false); } public function clear(){ $this->fields = []; } public function __construct($fields=null){ $this->load($fields); } public function load($fields){ if ($fields) $this->fields = (array)$fields; } public function merge($array, $merge_back=false){ $this->fields = $merge_back ? array_replace_recursive((array)$array, $this->fields) : array_replace_recursive($this->fields, (array)$array); } public function compact(){ $array_filter_rec = function($input, $callback = null) use (&$array_filter_rec) { foreach ($input as &$value) { if (is_array($value)) { $value = $array_filter_rec($value, $callback); } } return array_filter($input, $callback); }; $this->fields = $array_filter_rec($this->fields,function($a){ return $a !== null; }); } public function & find($path, $create=false, ?callable $operation=null) { $create ? $value =& $this->fields : $value = $this->fields; foreach (explode('.',$path) as $tok) if ($create || isset($value[$tok])) { $value =& $value[$tok]; } else { $value = $create ? $value : null; break; } if ( is_callable($operation) ) $operation($value); return $value; } public function jsonSerialize(): mixed { return $this->fields; } }class Message extends Dictionary { protected static $loaded = false; protected static $fields = []; protected static function init(){ if(false===static::$loaded){ static::load(Session::get('core.messages',[])); static::$loaded = true; } } public static function & get($key,$default=null){ static::init(); $value = parent::get($key,''); parent::delete($key,''); Session::set('core.messages',parent::all()); return $value; } public static function set($key,$data=null){ static::init(); parent::set($key,$data); return Session::set('core.messages',parent::all()); } public static function add($key,$data=null){ static::init(); $d = parent::get($key,[]); $d[] = $data; parent::set($key,$d); return Session::set('core.messages',parent::all()); } public static function & all($key=null){ static::init(); if($key){ $all = parent::get($key,[]); parent::delete($key); Session::set('core.messages',parent::all()); } else { $all = parent::all(); static::clear(); } return $all; } public static function clear(){ static::init(); parent::clear(); Session::delete('core.messages'); } public static function readOnly(){ return new MessageReadOnly(); } } class MessageReadOnly { public function __get($key){ return Message::get($key); } public function __isset($key){ return true; } }trait Module { static protected $__PROTOTYPE__ = array(); final public function __call($name, $args){ if (isset(static::$__PROTOTYPE__[$name]) && static::$__PROTOTYPE__[$name] instanceof \Closure) return call_user_func_array(static::$__PROTOTYPE__[$name]->bindTo($this, $this), $args); if (get_parent_class()) return parent::__call($name, $args); else throw new \BadMethodCallException; } final public static function __callStatic($name, $args){ if (isset(static::$__PROTOTYPE__[$name]) && static::$__PROTOTYPE__[$name] instanceof \Closure) return forward_static_call_array(static::$__PROTOTYPE__[$name], $args); if (get_parent_class()) return parent::__callStatic($name, $args); else throw new \BadMethodCallException; } public static function extend($method, $callback=null){ $methods = ($callback === null && is_array($method)) ? $method : [$method=>$callback]; foreach ($methods as $name => $meth) { if ($meth && $meth instanceof \Closure) static::$__PROTOTYPE__[$name] = $meth; else throw new \BadMethodCallException; } } }class Auth { use Module, Events; protected static $resolver = null, $tokenResolver = null, $userResolved = false, $user = null, $source = null, $identity = null; public static function boot(){ Route::extend([ 'auth' => function (array $options = []) { $this->before(function () use ($options) { if (!Auth::check()) { $status = $options['status'] ?? Options::get('core.auth.unauthorized.status', 401); $body = $options['body'] ?? Options::get('core.auth.unauthorized.body', 'Unauthorized'); Response::error($status, $body); if (!empty($body)) Response::add($body); return false; } }); }, 'guest' => function () { $this->before(function () { if (Auth::check()) { Response::error(403, 'Forbidden'); Response::add('Forbidden'); return false; } }); }, 'can' => function (string $ability, ...$args) { $this->before(function () use ($ability, $args) { if (!Gate::authorize($ability, ...$args)) { Response::error(403, 'Forbidden'); Response::add('Forbidden'); return false; } }); }, 'csrf' => function (array $options = []) { $this->before(function () use ($options) { if (!CSRF::shouldVerify()) return; if (!CSRF::verify($options)) { Response::error(419, 'CSRF token mismatch'); Response::add('CSRF token mismatch'); return false; } }); }, 'rateLimit' => function (int $limit, int $window = 60, ?string $key = null, array $options = []) { $this->before(function () use ($limit, $window, $key, $options) { if (!Options::get('core.security.rate_limit.enabled', true)) return; $result = RateLimiter::check( $key ?: RateLimiter::defaultKey(), $limit, $window ); RateLimiter::applyHeaders($limit, $result['remaining'], $result['reset']); if (!$result['allowed']) { $retry = max(0, $result['reset'] - time()); Response::header('Retry-After', (string)$retry); Response::error(429, $options['message'] ?? 'Too Many Requests'); Response::add($options['body'] ?? 'Too Many Requests'); return false; } }); }, 'secureHeaders' => function (array $overrides = []) { $this->before(function () use ($overrides) { SecurityHeaders::apply($overrides); }); }, ]); } public static function resolver(callable $resolver){ static::$resolver = $resolver; } public static function tokenResolver(callable $resolver){ static::$tokenResolver = $resolver; } public static function user(){ if (!static::$userResolved) static::resolve(); return static::$user; } public static function check(){ return (bool)static::user(); } public static function id(){ $user = static::user(); if (is_object($user)) { foreach (['id','ID','user_id','uid'] as $key) { if (isset($user->$key)) return $user->$key; } return $user; } if (is_array($user)) { foreach (['id','ID','user_id','uid'] as $key) { if (isset($user[$key])) return $user[$key]; } return $user; } return $user; } public static function source(){ if (!static::$userResolved) static::resolve(); return static::$source; } public static function identity(){ if (!static::$userResolved) static::resolve(); return static::$identity; } public static function login($identity){ if (!Options::get('core.auth.session.enabled', true)) return false; Session::start(); $key = Options::get('core.auth.session.key', 'auth.user'); Session::set($key, $identity); if (Options::get('core.auth.session.regenerate', true)) { @session_regenerate_id(true); } static::flush(); return true; } public static function logout(){ if (!Options::get('core.auth.session.enabled', true)) return false; Session::start(); $key = Options::get('core.auth.session.key', 'auth.user'); Session::delete($key); if (Options::get('core.auth.session.regenerate', true)) { @session_regenerate_id(true); } static::flush(); return true; } public static function flush(){ static::$userResolved = false; static::$user = null; static::$source = null; static::$identity = null; } protected static function resolve(){ static::$userResolved = true; static::$user = null; static::$source = null; static::$identity = null; $context = [ 'request' => [ 'ip' => Request::IP(), 'method' => Request::method(), 'uri' => Request::URI(), ], ]; if (Options::get('core.auth.session.enabled', true)) { $key = Options::get('core.auth.session.key', 'auth.user'); if (Session::exists($key)) { $identity = Session::get($key); static::$identity = $identity; static::$source = 'session'; static::$user = static::resolveUser($identity, 'session', $context); return; } } if (Options::get('core.auth.bearer.enabled', true)) { $headerName = Options::get('core.auth.bearer.header', 'Authorization'); $header = Request::header($headerName); $schemes = Options::get('core.auth.bearer.schemes', ['Bearer']); if ($header) { foreach ((array)$schemes as $scheme) { $prefix = $scheme . ' '; if (stripos($header, $prefix) === 0) { $token = trim(substr($header, strlen($prefix))); if ($token === '') break; $payload = null; $isJwt = substr_count($token, '.') === 2; if ($isJwt) { try { $secret = Options::get('core.auth.jwt.secret', null); $verify = $secret !== null && $secret !== ''; $payload = Token::decode($token, $secret, $verify); if ($payload && isset($payload->exp)) { if (time() >= (int)$payload->exp) { $payload = null; } } elseif (Options::get('core.auth.jwt.require_exp', false)) { $payload = null; } } catch (Throwable $e) { $payload = null; } } $identity = $payload ?: $token; $context['token'] = $token; $context['payload'] = $payload; static::$identity = $identity; static::$source = 'bearer'; $user = null; if (static::$tokenResolver) { $user = call_user_func(static::$tokenResolver, $token, $payload); } static::$user = $user !== null ? $user : static::resolveUser($identity, 'bearer', $context); return; } } } } } protected static function resolveUser($identity, $source, array $context){ if (static::$resolver) { return call_user_func(static::$resolver, $identity, $source, $context); } return $identity; } }class CLI { use Module, Events; protected static $file = null; protected static $arguments = []; protected static $options = []; protected static $commands = []; protected static $help = null; protected static $error = null; protected static $ui = null; protected static $shell_colors = [ 'BLACK' =>"\033[0;30m", 'DARKGRAY' =>"\033[1;30m", 'BLUE' =>"\033[0;34m", 'LIGHTBLUE' =>"\033[1;34m", 'GREEN' =>"\033[0;32m", 'LIGHTGREEN' =>"\033[1;32m", 'CYAN' =>"\033[0;36m", 'LIGHTCYAN' =>"\033[1;36m", 'RED' =>"\033[0;31m", 'LIGHTRED' =>"\033[1;31m", 'PURPLE' =>"\033[0;35m", 'LIGHTPURPLE' =>"\033[1;35m", 'BROWN' =>"\033[0;33m", 'YELLOW' =>"\033[1;33m", 'LIGHTGRAY' =>"\033[0;37m", 'WHITE' =>"\033[1;37m", 'NORMAL' =>"\033[0;37m", 'B' =>"\033[1m", 'ERROR' =>"\033[1;31m", 'INFO' =>"\033[0;36m", 'I' =>"\033[0;30;104m", 'IB' =>"\033[1;30;104m", 'U' =>"\033[4m", 'D' =>"\033[2m", ]; protected static $color_stack = ['NORMAL']; public static function on($command,callable $callback,$description=''){ $parts = preg_split('/\s+/',$command); static::$commands[array_shift($parts)] = [$parts,$callback,$description]; } public static function help(?callable $callback = null){ $callback ? is_callable($callback) && static::$help = $callback : static::$help && call_user_func(static::$help); } public static function error(?callable $callback = null){ $callback ? is_callable($callback) && static::$error = $callback : static::$error && call_user_func(static::$error); } public static function name(){ return static::$file; } protected static function triggerError($message){ is_callable(static::$error) && call_user_func(static::$error,$message); exit -1; } public static function input($key=null,$default=null){ return $key ? (isset(static::$options[$key]) ? static::$options[$key] : (is_callable($default)?call_user_func($default):$default)) : static::$options; } public static function commands(){ $results = []; foreach(static::$commands as $name => $cmd){ $results[] = [ 'name' => $name, 'params' => preg_replace('/:(\w+)/','[$1]',implode(' ',$cmd[0])), 'description' => $cmd[2], ]; } return $results; } public static function run($args=null){ if (PHP_SAPI != 'cli') return false; if($args) { $_args = $args; static::$file = basename(isset($_SERVER['PHP_SELF'])?$_SERVER['PHP_SELF']:__FILE__); } else { $_args = $_SERVER['argv']; static::$file = basename(array_shift($_args)); } foreach($_args as $e) if(strpos($e,'-')===0) { $h = explode('=',$e); static::$options[ltrim(current($h),'-')] = isset($h[1])?$h[1]:true; } else { static::$arguments[] = $e; } if(isset(static::$arguments[0])){ $command = array_shift(static::$arguments); if (empty(static::$commands[$command])) return static::triggerError("Unknown command [".$command."]."); $cmd = static::$commands[$command]; $pars_vector = []; foreach ($cmd[0] as $_idx => $segment) { if ($segment[0]==':'){ if (isset(static::$arguments[$_idx])){ $pars_vector[] = static::$arguments[$_idx]; } else return static::triggerError("Command [".$command."] needs more parameters"); } else { if (empty(static::$arguments[$_idx]) || $segment!=static::$arguments[$_idx]) return static::triggerError("Command [".$command."] is incomplete."); } } $returns = call_user_func_array($cmd[1], $pars_vector); echo is_scalar($returns) ? "$returns" : json_encode($returns, JSON_PRETTY_PRINT); return true; } else { static::help(); return false; } } public static function write($message){ if( preg_match('~<[^>]+>~',$message)) { echo strtr(preg_replace_callback('~^(.*)<([^>]+)>(.+)</\2>(.*)$~USm',function($m){ static::write($m[1]); $color = strtoupper(trim($m[2])); if( isset(static::$shell_colors[$color]) ) echo static::$shell_colors[$color]; static::$color_stack[] = $color; static::write($m[3]); array_pop(static::$color_stack); $back_color = array_pop(static::$color_stack) ?: static::$color_stack[]='NORMAL'; if( isset(static::$shell_colors[$back_color]) ) echo static::$shell_colors[$back_color]; static::write($m[4]); },strtr($message,["\n"=>"&BR;"])),["&BR;"=>PHP_EOL]); } else { echo strtr($message,["&BR;"=>PHP_EOL]); } } public static function writeln($message){ static::write($message . PHP_EOL); } public static function color($color){ if ( isset(static::$shell_colors[$color]) ) echo static::$shell_colors[$color]; } public static function edit($text,$filename=''){ $EDITOR = getenv('EDITOR')?:'nano'; $tmp = tempnam(sys_get_temp_dir(), "E-").strtr($filename,'/','_'); file_put_contents($tmp, $text); passthru("$EDITOR $tmp"); $result = file_get_contents($tmp); unlink($tmp); return $result; } public static function UI(){ if (!static::$ui) { static::$ui = new \CLI\UI\Facade(); } return static::$ui; } } CLI::help(function(){ echo 'Usage: ', CLI::name(),' [commands]', PHP_EOL, 'Commands:',PHP_EOL; foreach( CLI::commands() as $cmd ){ echo "\t", $cmd['name'], ' ' ,$cmd['params'], PHP_EOL; if($cmd['description']) echo "\t\t- ", str_replace("\n","\n\t\t  ",$cmd['description']), PHP_EOL, PHP_EOL; } }); CLI::error(function($message){ echo 'Error: ',$message,PHP_EOL; });class CSRF { use Module; public static function token(){ Session::start(); $key = Options::get('core.csrf.session_key', '_csrf'); if (!Session::exists($key)) { $token = static::generateToken(); Session::set($key, $token); } return Session::get($key); } public static function verify($options = []){ Session::start(); $key = Options::get('core.csrf.session_key', '_csrf'); if (!Session::exists($key)) return false; $headerName = $options['header'] ?? Options::get('core.csrf.header', 'X-CSRF-Token'); $inputName = $options['input'] ?? Options::get('core.csrf.input', '_csrf'); $token = Request::header($headerName); if (!$token) { $token = Request::input($inputName); if (is_object($token)) $token = null; } if (!$token) return false; $stored = Session::get($key); $valid = Password::compare($stored, $token); if ($valid && Options::get('core.csrf.rotate', true)) { Session::set($key, static::generateToken()); } return $valid; } public static function rotate(){ Session::start(); $key = Options::get('core.csrf.session_key', '_csrf'); Session::set($key, static::generateToken()); } public static function shouldVerify(){ $methods = Options::get('core.csrf.methods', ['post','put','patch','delete']); return in_array(strtolower(Request::method()), (array)$methods, true); } protected static function generateToken(){ if (function_exists('random_bytes')) { return bin2hex(random_bytes(32)); } return bin2hex(openssl_random_pseudo_bytes(32)); } }class CSV { use Module; const AUTO = null, STANDARD = ',', EXCEL = ';', TAB = "\t", READ = 'r', WRITE = 'w'; protected $file, $headers = [], $template = [], $mode = self::WRITE, $format = self::STANDARD, $savedheaders = false; public static function open($file, $format=self::AUTO){ return new static($file,self::READ,$format); } public static function create($file, $format=self::STANDARD){ return new static($file,self::WRITE, $format); } public function SQL($sql){ $csv = $this; SQL::each($sql,function($row) use (&$csv){ $csv->write($row); }); return $this; } public static function fromSQL($sql, $format=self::AUTO){ return static::create(tempnam(sys_get_temp_dir(), 'CSVx'), $format)->SQL($sql); } public static function fromTable($table, $format=self::AUTO){ $csv = static::create(tempnam(sys_get_temp_dir(), 'CSVx'), $format); foreach($table as $row){ $csv->write($row); } return $csv; } public function __construct($file, $mode=self::READ, $format=self::AUTO){ $this->mode = $mode; $this->file = new \SplFileObject($file,'c+'); if (!$this->file->valid()) throw new Exception("Error opening CSV file [$file]", 1); $this->file->setFlags( \SplFileObject::READ_CSV | \SplFileObject::SKIP_EMPTY | \SplFileObject::DROP_NEW_LINE ); $this->format = ($format==self::AUTO ? $this->guessSeparator() : $format); $this->file->setCsvControl($this->format,'"',"\\"); } private function guessSeparator($checkLines = 2){ if ($this->mode == self::WRITE) return self::STANDARD; $delimiters = [",","\t",";"]; $results = []; $this->file->rewind(); while ($checkLines--) { $line = $this->file->fgets(); foreach ($delimiters as $delimiter){ $fields = preg_split('/['.$delimiter.']/', $line); if(count($fields) > 1){ if(empty($results[$delimiter])){ $results[$delimiter] = 1; } else { $results[$delimiter]++; } } } } $this->file->rewind(); $results = array_keys($results, max($results)); return $results[0]; } public function write($row){ if ($this->mode != self::WRITE) return; $row = (array)$row; if (false === $this->savedheaders) { $this->schema(array_keys($row)); } $row_t = $this->template; foreach ($this->headers as $key) { if (isset($row[$key])) $row_t[$key] = $row[$key]; } $this->file->fputcsv($row_t); } public function read(){ if ($this->mode != self::READ) return; foreach($this->file as $row){ if ($row){ if(!$this->headers) { $this->headers = $row; continue; } yield array_combine($this->headers, array_map('trim', $row)); } } return; } public function each(?callable $looper = null){ if ($looper) { foreach($this->read() as $k => $row) $looper($row, (int)$k); return $this; } else { $results = []; foreach($this->read() as $row) $results[] = $row; return $results; } } public function convert($filename, $format=self::STANDARD){ if ($this->mode != self::READ) return; if ($format == self::AUTO) $format = self::STANDARD; $csv = CSV::create($filename, CSV::EXCEL); $this->each(function($row) use ($csv) { $csv->write($row); }); return $csv; } public function flush(){ if ($this->mode == self::WRITE) { $this->file->fflush(); } } public function schema($schema=null){ if($schema){ $this->headers = array_values((array)$schema); if ($this->mode == self::WRITE) { $this->savedheaders = true; $this->template = array_combine($this->headers, array_pad([],count($this->headers),'')); $this->file->fputcsv($this->headers); } return $this; } else { return $this->headers; } } public function asString(){ $this->flush(); return file_get_contents($this->file->getPathname()); } public function __toString(){ try { return $this->asString(); } catch(\Exception $e) { return ''; } } }class Cache { use Module, Events; protected static $driver = null, $enabled = true; public static function get($key, $default='', $expire=0){ if (static::$enabled){ $hash = static::hash($key); if(static::$driver->exists($hash) && $results = static::$driver->get($hash)){ return $results; } else { if($data = is_callable($default)?call_user_func($default):$default){ static::$driver->set($hash,$data,$expire); } return $data; } } else { return is_callable($default) ? call_user_func($default) : $default; } } public static function using($driver){ foreach((array)$driver as $key => $value){ if(is_numeric($key)){ $drv = $value; $conf = []; } else { $drv = $key; $conf = $value; } $class = 'Cache\\' . ucfirst(strtolower($drv)); if(class_exists($class) && $class::valid()) { static::$driver = new $class($conf); return true; } } return false; } public static function enabled($enabled=null){ return $enabled ? static::$enabled : static::$enabled = $enabled; } public static function set($key, $value, $expire=0){ return static::$driver->set(static::hash($key),$value,$expire); } public static function delete($key){ return static::$driver->delete(static::hash($key)); } public static function exists($key){ return static::$enabled && static::$driver->exists(static::hash($key)); } public static function flush(){ return static::$driver->flush(); } public static function inc($key, $value=1){ return static::$driver->inc(static::hash($key),$value); } public static function dec($key, $value=1){ return static::$driver->dec(static::hash($key),$value); } public static function hash($key, $group=null){ static $hashes = []; $groupKey = $group ?? ''; if (false === isset($hashes[$groupKey][$key])){ $k = $key; if(is_array($key) && count($key)>1) { list($group,$key) = $k; $groupKey = $group ?? ''; } $hashes[$groupKey][$key] = ($group?$group.'-':'') . md5($key); } return $hashes[$groupKey][$key]; } } Cache::using(['files','memory']);class Check { use Module, Events; protected static $methods = [], $errors = []; public static $data = []; public static function valid($rules, $data){ static::$errors = []; static::triggerOnce('init'); self::$data = ($data = (array)$data); foreach ((array)$rules as $field_name => $rule) { $current = isset($data[$field_name]) ? $data[$field_name] : null; if (is_callable($rule)){ static::$errors[$field_name] = call_user_func($rule,$current); continue; } elseif (is_string($rule)) { $current_rules = array_flip(preg_split('/\s*\|\s*/', $rule)); } else { $current_rules = (array)$rule; } static::$errors[$field_name] = true; foreach($current_rules as $method => $message) { $meth_name = strtok($method, ':'); $opts = strtok(':') ?: ''; $opts = $opts ? json_decode("[$opts]") : []; $meth_opts = $opts ? array_merge([$current], $opts) : [$current]; if ( static::$errors[$field_name] !== true ) continue 2; if (empty(static::$methods[$meth_name])) { static::$errors[$field_name] = true; } else { if (call_user_func_array(static::$methods[$meth_name]->validate,$meth_opts)){ static::$errors[$field_name] = true; } else { $arg = []; foreach ($meth_opts as $key => $value) { $arg["arg_$key"] = $value; } static::$errors[$field_name] = Text::render(static::$methods[$meth_name]->message,$arg); } } } } self::$data = []; static::$errors = array_filter(static::$errors,function($v){ return $v !== true; }); return empty(static::$errors); } public static function method($name, $definition = null){ if (is_array($name)) { foreach ($name as $method_name => $method_definition){ if (is_callable($method_definition)) $method_definition = ['validate' => $method_definition]; if (empty($method_definition['validate']) || !is_callable($method_definition['validate'])) continue; $method_definition['message'] = Filter::with("core.check.error.$method_name",@$method_definition['message']?:'Field not valid.'); static::$methods[$method_name] = (object)$method_definition; } } else { if (is_callable($definition)) $definition = ['validate' => $definition]; if (empty($definition['validate']) || !is_callable($definition['validate'])) return; $methods['message'] = Filter::with("core.check.error.$name",@$methods['message']?:'Field not valid.'); static::$methods[$name] = (object)$definition; } } public static function errors() { return static::$errors; } } Check::on('init',function(){ Check::method([ 'required' => [ 'validate' => function($value) { return (is_numeric($value) && $value==0) || !empty($value); }, 'message' => "This value cannot be empty.", ], 'alphanumeric' => [ 'validate' => function($value) { return (bool)preg_match('/^[0-9a-zA-Z]+$/',$value); }, 'message' => "Value must be alphanumeric.", ], 'numeric' => [ 'validate' => function($value) { return (bool)preg_match('/^\d+$/',$value); }, 'message' => "Value must be numeric.", ], 'email' => [ 'validate' => function($value) { return (bool)filter_var($value, FILTER_VALIDATE_EMAIL); }, 'message' => "This is not a valid email.", ], 'url' => [ 'validate' => function($value) { return (bool)filter_var($value, FILTER_VALIDATE_URL); }, 'message' => "This is not a valid URL.", ], 'max' => [ 'validate' => function($value,$max) { return $value<=$max ? true : false; }, 'message' => "Value must be less than {{arg_1}}.", ], 'min' => [ 'validate' => function($value,$min) { return $value >= $min; }, 'message' => "Value must be greater than {{arg_1}}.", ], 'range' => [ 'validate' => function($value,$min,$max) { return ( $value >= $min ) && ( $value <= $max ); }, 'message' => "This value must be in [{{arg_1}},{{arg_2}}] range.", ], 'words' => [ 'validate' => function($value,$max) { return str_word_count($value) <= $max; }, 'message' => "Too many words, max count is {{arg_1}}.", ], 'length' => [ 'validate' => function($value,$length) { return strlen($value) == $length; }, 'message' => "This value must be {{arg_1}} characters.", ], 'min_length' => [ 'validate' => function($value,$min) { return strlen($value) >= $min; }, 'message' => "Too few characters, min count is {{arg_1}}.", ], 'max_length' => [ 'validate' => function($value,$max) { return strlen($value) <= $max; }, 'message' => "Too many characters, max count is {{arg_1}}.", ], 'true' => [ 'validate' => function($value) { return (bool)$value; }, 'message' => "This value must be true.", ], 'false' => [ 'validate' => function($value) { return !$value; }, 'message' => "This value must be false.", ], 'same_as' => [ 'validate' => function($value,$fieldname) { $x = isset(Check::$data[$fieldname]) ? Check::$data[$fieldname] : ''; return $value == $x; }, 'message' => "Field must be equal to {{arg_1}}.", ], 'in_array' => [ 'validate' => function($value,$array_values) { return in_array($value, $array_values); }, 'message' => "This value is forbidden.", ], ]); });class Crypt { use Module; public static function encrypt($data, $key) { $key = static::normalizeKey($key); if (function_exists('sodium_crypto_secretbox')) { $nonce = random_bytes(SODIUM_CRYPTO_SECRETBOX_NONCEBYTES); $cipher = sodium_crypto_secretbox($data, $nonce, $key); return base64_encode($nonce . $cipher); } if (function_exists('openssl_encrypt')) { $method = 'aes-256-gcm'; $ivlen = openssl_cipher_iv_length($method); $iv = random_bytes($ivlen); $tag = ''; $cipher = openssl_encrypt($data, $method, $key, OPENSSL_RAW_DATA, $iv, $tag, '', 16); return base64_encode($iv . $tag . $cipher); } throw new \RuntimeException('Crypt requires sodium or openssl extension'); } public static function decrypt($ciphertext, $key) { $key = static::normalizeKey($key); $raw = base64_decode($ciphertext, true); if ($raw === false) return false; if (function_exists('sodium_crypto_secretbox_open')) { if (strlen($raw) < SODIUM_CRYPTO_SECRETBOX_NONCEBYTES + SODIUM_CRYPTO_SECRETBOX_MACBYTES) { return false; } $nonce = substr($raw, 0, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES); $cipher = substr($raw, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES); $plain = sodium_crypto_secretbox_open($cipher, $nonce, $key); return $plain === false ? false : $plain; } if (function_exists('openssl_decrypt')) { $method = 'aes-256-gcm'; $ivlen = openssl_cipher_iv_length($method); $taglen = 16; if (strlen($raw) < $ivlen + $taglen) return false; $iv = substr($raw, 0, $ivlen); $tag = substr($raw, $ivlen, $taglen); $cipher = substr($raw, $ivlen + $taglen); $plain = openssl_decrypt($cipher, $method, $key, OPENSSL_RAW_DATA, $iv, $tag); return $plain === false ? false : $plain; } throw new \RuntimeException('Crypt requires sodium or openssl extension'); } public static function key() { if (function_exists('sodium_crypto_secretbox_keygen')) { return bin2hex(sodium_crypto_secretbox_keygen()); } return bin2hex(random_bytes(32)); } public static function available() { return function_exists('sodium_crypto_secretbox') || function_exists('openssl_encrypt'); } protected static function normalizeKey($key) { if (ctype_xdigit($key) && strlen($key) >= 32) { $key = hex2bin(substr($key, 0, 64)); } $required = function_exists('sodium_crypto_secretbox') ? SODIUM_CRYPTO_SECRETBOX_KEYBYTES : 32; $key = str_pad(substr($key, 0, $required), $required, "\0"); return $key; } }class Email { use Module, Events; protected static $driver, $options, $driver_name; public static function using($driver, $options = null){ $class = 'Email\\'.ucfirst(strtolower($driver)); if ( ! class_exists($class) ) throw new Exception("[core.email] : $driver driver not found."); static::$driver_name = $driver; static::$options = $options; static::$driver = new $class; static::$driver->onInit($options); } public static function create($mail=[]){ if (is_a($mail, 'Email\\Envelope')){ return $mail; } else { return new Email\Envelope(array_merge([ 'to' => false, 'from' => false, 'cc' => false, 'bcc' => false, 'replyTo' => false, 'subject' => false, 'message' => false, 'attachments' => [], ], $mail)); } } public static function send($mail){ $envelope = static::create($mail); $results = (array) static::$driver->onSend($envelope); static::trigger('send', $envelope->to(), $envelope, static::$driver_name, $results); Event::trigger('core.email.send', $envelope->to(), $envelope, static::$driver_name, $results); return count($results) && array_reduce( $results, function($carry, $item) { return $carry && $item; }, true ); } } if (class_exists('Email\\Native', true)) { Email::using('native'); }class Errors { use Module, Events; const SIMPLE = 0; const HTML = 1; const SILENT = 2; const JSON = 3; const JSON_VERBOSE = 4; static $mode = self::SILENT; public static function capture($tracing_level=null){ if($tracing_level!==null) error_reporting($tracing_level); set_error_handler(__CLASS__.'::traceError'); set_exception_handler(__CLASS__.'::traceException'); } public static function mode($mode=null){ return $mode ? self::$mode=$mode : self::$mode; } public static function traceError($errno,$errstr,$errfile=null,$errline=null){ if (!(error_reporting() & $errno)) return; switch ( $errno ) { case E_USER_ERROR: $type = 'Fatal'; break; case E_USER_WARNING: case E_WARNING: $type = 'Warning'; break; case E_USER_NOTICE: case E_NOTICE: case E_STRICT: $type = 'Notice'; break; default: $type = 'Error'; break; } $e = new \ErrorException($type.': '.$errstr, 0, $errno, $errfile, $errline); $error_type = strtolower($type); $chk_specific = array_filter(array_merge( (array)static::trigger($error_type,$e), (array)Event::trigger("core.error.$error_type",$e) )); $chk_general = array_filter(array_merge( (array)static::trigger('any',$e), (array)Event::trigger('core.error',$e) )); if (! ($chk_specific || $chk_general) ) static::traceException($e); return true; } public static function traceException($e){ switch(self::$mode){ case self::HTML : echo '<pre class="app error"><code>',$e->getMessage(),'</code></pre>',PHP_EOL; break; case self::JSON : echo json_encode(['error' => $e->getMessage()]); break; case self::JSON_VERBOSE : echo json_encode(static::structuredException($e)); break; case self::SILENT : break; case self::SIMPLE : default: echo $e->getMessage(),PHP_EOL; break; } return true; } public static function structuredException($e) { $data = [ 'error' => $e->getMessage(), 'type' => get_class($e), 'code' => $e->getCode(), 'file' => $e->getFile(), 'line' => $e->getLine(), 'trace' => [], ]; foreach ($e->getTrace() as $frame) { $entry = []; if (isset($frame['file'])) $entry['file'] = $frame['file']; if (isset($frame['line'])) $entry['line'] = $frame['line']; $entry['function'] = $frame['function']; if (isset($frame['class'])) $entry['class'] = $frame['class']; $data['trace'][] = $entry; } if ($e->getPrevious()) { $data['previous'] = static::structuredException($e->getPrevious()); } return $data; } public static function onFatal(callable $listener){ Event::on('core.error.fatal',$listener); } public static function onWarning(callable $listener){ Event::on('core.error.warning',$listener); } public static function onNotice(callable $listener){ Event::on('core.error.notice',$listener); } public static function onAny(callable $listener){ Event::on('core.error',$listener); } }if (!class_exists('Errors', false)) { include_once __DIR__ . '/Errors.php'; } if (!class_exists('Error', false)) { class_alias('Errors', 'Error', true); }class Event { use Module, Events; public static function single($name,callable $listener){ return static::onSingle($name,$listener); } }class File { use Module, Events; protected static $mount_points = []; public static function mount($alias, $driver, $options = null) { $driver_class = '\\FileSystem\\'.ucfirst(strtolower($driver)); if (!class_exists($driver_class)) throw new \Exception('Filesystem adapter '.$driver.' not found.'); static::$mount_points[$alias] = new $driver_class($options); static::trigger("mount",$alias, $driver_class, static::$mount_points[$alias]); } public static function unmount($alias) { unset(static::$mount_points[$alias]); static::trigger("unmount",$alias); } public static function mounts() { return array_keys(static::$mount_points); } public static function __callStatic($name, $params) { $uri = array_shift($params); if ($file_location = static::locate($uri)){ list($mount, $path) = $file_location; array_unshift($params, static::resolvePath($path)); if (empty(static::$mount_points[$mount])) return false; return call_user_func_array([static::$mount_points[$mount],$name],$params); } else return false; } public static function locate($path) { if (strpos($path,'://')!==false) { list($mount, $filepath) = explode('://',$path,2); $filepath = static::resolvePath($filepath); return isset(static::$mount_points[$mount]) ? [$mount, $filepath] : false; } else { $path = static::resolvePath($path); foreach(static::$mount_points as $mount => $fs){ if ($fs->exists($path)) return [$mount, $path]; } return false; } } public static function resolvePath($path) { $path = str_replace(['/', '\\'], '/', $path); $parts = array_filter(explode('/', $path), 'strlen'); $absolutes = []; foreach ($parts as $part) { if ('.' == $part) continue; if ('..' == $part) { array_pop($absolutes); } else { $absolutes[] = $part; } } return trim(implode('/', $absolutes),'/'); } public static function search($pattern, $recursive=true){ $results = []; foreach (static::$mount_points as $mount => $fs) { foreach($fs->search($pattern, $recursive) as $path) { $results[] = $mount.'://'.$path; } } return $results; } public static function move($old,$new) { $src = static::locate($old); $dest = static::locate($new); if ($src && $dest) { $_sfs = static::$mount_points[$src[0]]; $_dfs = static::$mount_points[$dest[0]]; if ($src[0] == $dest[0]) { return $_sfs->move($src[1],$dest[1]); } else { return $_dfs->write($dest[1],$_sfs->read($src[1])) && $_sfs->delete($src[1]); } } else return false; } }$__old_er = error_reporting(); error_reporting(E_ALL & ~E_DEPRECATED); class Filter { use Module, Filters { filter as add; filterSingle as single; filterRemove as remove; filterWith as with; } } error_reporting($__old_er);class Gate { use Module; protected static $abilities = []; public static function define($ability, callable $callback){ static::$abilities[$ability] = $callback; } public static function allows($ability, ...$args){ if (empty(static::$abilities[$ability])) return false; $user = Auth::user(); return (bool)call_user_func(static::$abilities[$ability], $user, ...$args); } public static function authorize($ability, ...$args){ return static::allows($ability, ...$args); } }class HTTP { use Module, Events; protected static $UA = "Mozilla/4.0 (compatible; Core::HTTP; Windows NT 6.1)", $json_data = false, $headers = [], $last_response_header = null, $last_response_body = null, $last_info = null, $proxy = null, $verify_ssl = true, $timeout = 30; protected static function request($method, $url, $data=[], array $headers=[], $data_as_json=false, $username=null, $password = null){ preg_match('/.+(?::([0-9]+))\/?/i', $url, $match); $port = count($match) > 1 ? $match[1] : 80; $http_method = strtoupper($method); $ch = curl_init($url); $opt = [ CURLOPT_CUSTOMREQUEST => $http_method, CURLOPT_SSL_VERIFYHOST => static::$verify_ssl ? 2 : 0, CURLOPT_SSL_VERIFYPEER => static::$verify_ssl ? true : false, CURLOPT_CONNECTTIMEOUT => 10, CURLOPT_TIMEOUT => static::$timeout, CURLOPT_RETURNTRANSFER => true, CURLOPT_USERAGENT => static::$UA, CURLOPT_HEADER => true, CURLOPT_VERBOSE => true, CURLOPT_MAXREDIRS => 10, CURLOPT_FOLLOWLOCATION => true, CURLOPT_ENCODING => '', CURLOPT_PROXY => static::$proxy, CURLOPT_PORT => $port ]; if($username && $password) { $opt[CURLOPT_USERPWD] = "$username:$password"; } $headers = array_merge($headers,static::$headers); if($http_method == 'GET'){ if($data && is_array($data)){ $tmp = []; $queried_url = $url; foreach($data as $key=>$val) $tmp[] = $key.'='.$val; $queried_url .= (strpos($queried_url,'?') === false) ? '?' : '&'; $queried_url .= implode('&',$tmp); $opt[CURLOPT_URL] = $queried_url; $opt[CURLOPT_HTTPGET] = true; unset($opt[CURLOPT_CUSTOMREQUEST]); } } else { $opt[CURLOPT_CUSTOMREQUEST] = $http_method; if($data_as_json or is_object($data)){ $headers['Content-Type'] = 'application/json'; $opt[CURLOPT_POSTFIELDS] = json_encode($data); } else { $opt[CURLOPT_POSTFIELDS] = http_build_query($data); } } curl_setopt_array($ch,$opt); $_harr = []; foreach($headers as $key=>$val) $_harr[] = $key.': '.$val; curl_setopt($ch, CURLOPT_HTTPHEADER, $_harr); $result = curl_exec($ch); $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE); $contentType = strtolower(curl_getinfo($ch, CURLINFO_CONTENT_TYPE)); static::$last_response_header = substr($result, 0, $header_size); $result = substr($result, $header_size); static::$last_info = curl_getinfo($ch); if(false !== strpos($contentType,'json')) $result = json_decode($result); curl_close($ch); static::trigger("request", $result, static::$last_info); Event::trigger("core.http.request", $url, $http_method, static::$last_info, $result); Event::trigger("core.log", "http.request", ["url" => $url, "method" => $http_method, "info" => static::$last_info]); static::$last_response_body = $result; return $result; } public static function useJSON($value=null){ return $value===null ? static::$json_data : static::$json_data = $value; } protected static function trasformRawHeaders($headers) { foreach (explode("\r\n", trim($headers)) as $line) { if (empty($line)) continue; $splitted = explode(':', $line); $res[isset($splitted[1])? trim($splitted[0]) : 'extra'][] = trim(end($splitted)); } return $res; } public static function lastResponseBody(){ return static::$last_response_body; } public static function lastResponseHeader(){ if (static::$last_response_header && !is_array(static::$last_response_header)) { static::$last_response_header = static::trasformRawHeaders(static::$last_response_header); } return static::$last_response_header; } public static function addHeader($name,$value){ static::$headers[$name] = $value; } public static function removeHeader($name){ unset(static::$headers[$name]); } public static function headers($name=null){ return null === $name ? static::$headers : ( isset(static::$headers[$name]) ? static::$headers[$name] : '' ); } public static function userAgent($value=null){ return $value===null ? static::$UA : static::$UA = $value; } public static function proxy($value=false){ return $value===false ? static::$proxy : static::$proxy = $value; } public static function verify($value=null){ return $value===null ? static::$verify_ssl : static::$verify_ssl = (bool)$value; } public static function timeout($seconds=null){ if ($seconds === null) return static::$timeout; $seconds = (int)$seconds; if ($seconds < 1) $seconds = 1; return static::$timeout = $seconds; } public static function get($url, $data=null, array $headers=[], $username = null, $password = null){ return static::request('get',$url,$data,$headers,false,$username,$password); } public static function post($url, $data=null, array $headers=[], $username = null, $password = null){ return static::request('post',$url,$data,$headers,static::$json_data,$username,$password); } public static function put($url, $data=null, array $headers=[], $username = null, $password = null){ return static::request('put',$url,$data,$headers,static::$json_data,$username,$password); } public static function delete($url, $data=null, array $headers=[], $username = null, $password = null){ return static::request('delete',$url,$data,$headers,static::$json_data,$username,$password); } public static function info($url = null){ if ($url){ curl_setopt_array($ch = curl_init($url), [ CURLOPT_SSL_VERIFYHOST => false, CURLOPT_CONNECTTIMEOUT => 10, CURLOPT_RETURNTRANSFER => true, CURLOPT_USERAGENT => static::$UA, CURLOPT_HEADER => false, CURLOPT_ENCODING => '', CURLOPT_FILETIME => true, CURLOPT_NOBODY => true, CURLOPT_PROXY => static::$proxy, ]); curl_exec($ch); $info = curl_getinfo($ch); curl_close($ch); return $info; } else { return static::$last_info; } } } class HTTP_Request { public $method = 'GET', $url = null, $headers = [], $body = ''; public function __construct($method, $url, $headers=[], $data=null){ $this->method = strtoupper($method); $this->url = new URL($url); $this->headers = (array)$headers; if ($data) { if (isset($this->headers["Content-Type"]) && $this->headers["Content-Type"]=='application/json') $this->body = json_encode($data); else $this->body = http_build_query($data); } } public function __toString(){ $path = $this->url->path ?: ''; $path = '/' . ltrim($path, '/'); $query = $this->url->query; if (is_array($query)) { $query = $query ? ('?' . http_build_query($query)) : ''; } else { $query = $query ? (str_starts_with($query, '?') ? $query : '?' . $query) : ''; } $headers = []; foreach ((array)$this->headers as $key => $val) { $headers[] = is_int($key) ? $val : ($key . ': ' . $val); } $header_block = $headers ? implode("\r\n", $headers) . "\r\n" : ''; return "$this->method {$path}{$query} HTTP/1.1\r\n" ."Host: {$this->url->host}\r\n" .$header_block ."\r\n{$this->body}"; } } class HTTP_Response { public $status = 200, $headers = [], $contents = ''; public function __construct($contents, $status, $headers){ $this->status = $status; $this->contents = $contents; $this->headers = (array)$headers; } public function __toString(){ return $this->contents; } }class Hash { use Module; public static function make($payload, $method = 'md5', $raw_output = false) { return $method == 'murmur' ? static::murmur(serialize($payload)) : hash($method, serialize($payload), $raw_output); } public static function verify($payload, $hash, $method = 'md5') { return static::make($payload, $method) == $hash; } public static function methods() { return array_merge(hash_algos(), ['murmur','murmurhash3']); } public static function can($algo) { return strpos(implode(',',static::methods()).',', "$algo,") !== false; } public static function __callStatic($method, $params) { return self::make(current($params), $method); } public static function uuid($type = 4, $namespace = '', $name = '') { switch ($type) { case 3:if (preg_match('/^\{?[0-9a-f]{8}\-?[0-9a-f]{4}\-?[0-9a-f]{4}\-?' . '[0-9a-f]{4}\-?[0-9a-f]{12}\}?$/Si', $namespace) !== 1) { return false; } $nhex = str_replace(array('-', '{', '}'), '', $namespace); $nstr = '';for ($i = 0; $i < strlen($nhex); $i += 2) { $nstr .= chr(hexdec($nhex[$i] . $nhex[$i + 1])); } $hash = md5($nstr . $name); return sprintf('%08s-%04s-%04x-%04x-%12s', substr($hash, 0, 8), substr($hash, 8, 4), (hexdec(substr($hash, 12, 4)) & 0x0fff) | 0x3000, (hexdec(substr($hash, 16, 4)) & 0x3fff) | 0x8000, substr($hash, 20, 12)); case 5:if (preg_match('/^\{?[0-9a-f]{8}\-?[0-9a-f]{4}\-?[0-9a-f]{4}\-?' . '[0-9a-f]{4}\-?[0-9a-f]{12}\}?$/Si', $namespace) !== 1) { return false; } $nhex = str_replace(array('-', '{', '}'), '', $namespace); $nstr = '';for ($i = 0; $i < strlen($nhex); $i += 2) { $nstr .= chr(hexdec($nhex[$i] . $nhex[$i + 1])); } $hash = sha1($nstr . $name); return sprintf('%08s-%04s-%04x-%04x-%12s', substr($hash, 0, 8), substr($hash, 8, 4), (hexdec(substr($hash, 12, 4)) & 0x0fff) | 0x5000, (hexdec(substr($hash, 16, 4)) & 0x3fff) | 0x8000, substr($hash, 20, 12)); default:case 4:return sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x', mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0x0fff) | 0x4000, mt_rand(0, 0x3fff) | 0x8000, mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)); } } public static function murmur($key, $seed = 0, $as_integer=false) { $key = array_values(unpack('C*',(string) $key)); $klen = count($key); $h1 = (int)$seed; for ($i=0,$bytes=$klen-($remainder=$klen&3) ; $i<$bytes ; ) { $k1 = $key[$i] | ($key[++$i] << 8) | ($key[++$i] << 16) | ($key[++$i] << 24); ++$i; $k1 = (((($k1 & 0xffff) * 0xcc9e2d51) + ((((($k1 >= 0 ? $k1 >> 16 : (($k1 & 0x7fffffff) >> 16) | 0x8000)) * 0xcc9e2d51) & 0xffff) << 16))) & 0xffffffff; $k1 = $k1 << 15 | ($k1 >= 0 ? $k1 >> 17 : (($k1 & 0x7fffffff) >> 17) | 0x4000); $k1 = (((($k1 & 0xffff) * 0x1b873593) + ((((($k1 >= 0 ? $k1 >> 16 : (($k1 & 0x7fffffff) >> 16) | 0x8000)) * 0x1b873593) & 0xffff) << 16))) & 0xffffffff; $h1 ^= $k1; $h1 = $h1 << 13 | ($h1 >= 0 ? $h1 >> 19 : (($h1 & 0x7fffffff) >> 19) | 0x1000); $h1b = (((($h1 & 0xffff) * 5) + ((((($h1 >= 0 ? $h1 >> 16 : (($h1 & 0x7fffffff) >> 16) | 0x8000)) * 5) & 0xffff) << 16))) & 0xffffffff; $h1 = ((($h1b & 0xffff) + 0x6b64) + ((((($h1b >= 0 ? $h1b >> 16 : (($h1b & 0x7fffffff) >> 16) | 0x8000)) + 0xe654) & 0xffff) << 16)); } $k1 = 0; switch ($remainder) { case 3: $k1 ^= $key[$i + 2] << 16; case 2: $k1 ^= $key[$i + 1] << 8; case 1: $k1 ^= $key[$i]; $k1 = ((($k1 & 0xffff) * 0xcc9e2d51) + ((((($k1 >= 0 ? $k1 >> 16 : (($k1 & 0x7fffffff) >> 16) | 0x8000)) * 0xcc9e2d51) & 0xffff) << 16)) & 0xffffffff; $k1 = $k1 << 15 | ($k1 >= 0 ? $k1 >> 17 : (($k1 & 0x7fffffff) >> 17) | 0x4000); $k1 = ((($k1 & 0xffff) * 0x1b873593) + ((((($k1 >= 0 ? $k1 >> 16 : (($k1 & 0x7fffffff) >> 16) | 0x8000)) * 0x1b873593) & 0xffff) << 16)) & 0xffffffff; $h1 ^= $k1; } $h1 ^= $klen; $h1 ^= ($h1 >= 0 ? $h1 >> 16 : (($h1 & 0x7fffffff) >> 16) | 0x8000); $h1 = ((($h1 & 0xffff) * 0x85ebca6b) + ((((($h1 >= 0 ? $h1 >> 16 : (($h1 & 0x7fffffff) >> 16) | 0x8000)) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff; $h1 ^= ($h1 >= 0 ? $h1 >> 13 : (($h1 & 0x7fffffff) >> 13) | 0x40000); $h1 = (((($h1 & 0xffff) * 0xc2b2ae35) + ((((($h1 >= 0 ? $h1 >> 16 : (($h1 & 0x7fffffff) >> 16) | 0x8000)) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff; $h1 ^= ($h1 >= 0 ? $h1 >> 16 : (($h1 & 0x7fffffff) >> 16) | 0x8000); return $as_integer ? $h1 : base_convert($h1 ,10, 32); } public static function random($bytes=9){ return strtr(base64_encode(static::random_bytes($bytes)),'+/=','-_'); } public static function random_bytes($bytes){ static $randf = null; if (function_exists('random_bytes')) { return \random_bytes($bytes); } else if (function_exists('mcrypt_create_iv')) { return @\mcrypt_create_iv($bytes, MCRYPT_DEV_URANDOM); } else { if (null === $randf) { if ($randf = fopen('/dev/urandom', 'rb')) { $st = fstat($randf); function_exists('stream_set_read_buffer') && stream_set_read_buffer($randf, 8); function_exists('stream_set_chunk_size') && stream_set_chunk_size($randf, 8); if (($st['mode'] & 0170000) !== 020000) { fclose($randf); $randf = false; } } } if ($randf) { $remaining = $bytes; $buf = ''; do { $read = fread($randf, $remaining); if ($read === false) { $buf = false; break; } $remaining -= strlen($read); $buf .= $read; } while ($remaining > 0); if ($buf !== false) { if (strlen($buf) === $bytes) { return $buf; } } } } } }class Introspect { use Module; public static function classes() { $classes = []; foreach (get_declared_classes() as $class) { $ref = new \ReflectionClass($class); $file = $ref->getFileName(); if ($file && static::isCoreFile($file)) { $classes[] = $class; } } foreach (get_declared_traits() as $trait) { $ref = new \ReflectionClass($trait); $file = $ref->getFileName(); if ($file && static::isCoreFile($file)) { $classes[] = $trait; } } foreach (get_declared_interfaces() as $iface) { $ref = new \ReflectionClass($iface); $file = $ref->getFileName(); if ($file && static::isCoreFile($file)) { $classes[] = $iface; } } sort($classes); return $classes; } public static function methods($class) { if (!class_exists($class) && !trait_exists($class) && !interface_exists($class)) return []; $ref = new \ReflectionClass($class); $methods = []; foreach ($ref->getMethods(\ReflectionMethod::IS_PUBLIC) as $method) { $methods[] = $method->getName(); } $extended = static::extensions($class); $methods = array_unique(array_merge($methods, $extended)); sort($methods); return $methods; } public static function extensions($class) { if (!class_exists($class)) return []; $ref = new \ReflectionClass($class); $traits = static::allTraits($ref); if (!in_array('Module', $traits, true)) return []; try { $prop = $ref->getProperty('__PROTOTYPE__'); $prop->setAccessible(true); $proto = $prop->getValue(); return is_array($proto) ? array_keys($proto) : []; } catch (\ReflectionException $e) { return []; } } public static function routes() { $result = []; if (!class_exists('Route') || !isset(Route::$routes)) return $result; foreach ((array)Route::$routes as $group => $list) { foreach ((array)$list as $route) { if (!is_a($route, 'Route')) continue; $ref = new \ReflectionObject($route); $data = []; foreach (['URLPattern', 'methods', 'tag', 'dynamic'] as $prop) { if ($ref->hasProperty($prop)) { $p = $ref->getProperty($prop); $p->setAccessible(true); $data[$prop] = $p->getValue($route); } } $result[] = [ 'pattern' => $data['URLPattern'] ?? '', 'methods' => array_keys($data['methods'] ?? []), 'tag' => $data['tag'] ?? '', 'dynamic' => $data['dynamic'] ?? false, ]; } } return $result; } public static function capabilities() { return [ 'redis' => extension_loaded('redis'), 'sodium' => extension_loaded('sodium') || function_exists('sodium_crypto_secretbox'), 'curl' => extension_loaded('curl'), 'pdo' => extension_loaded('pdo'), 'sqlite' => extension_loaded('pdo_sqlite'), 'mysql' => extension_loaded('pdo_mysql'), 'mbstring' => extension_loaded('mbstring'), 'openssl' => extension_loaded('openssl'), 'gd' => extension_loaded('gd'), 'zip' => extension_loaded('zip'), 'json' => function_exists('json_encode'), 'session' => function_exists('session_start'), 'core' => [ 'zero_runtime_dependencies' => static::runtimeDependencyCount() === 0, 'runtime_dependency_count' => static::runtimeDependencyCount(), 'introspection_available' => true, 'route' => [ 'loop_mode' => (bool) Options::get('core.route.loop_mode', false), 'loop_dispatcher' => (string) Options::get('core.route.loop_dispatcher', 'fast'), 'debug' => (bool) Options::get('core.route.debug', false), ], 'auth' => [ 'booted' => static::hasRouteExtension('auth'), ], 'cache' => [ 'driver_loaded' => static::cacheDriverName() !== '', 'driver' => static::cacheDriverName(), ], 'schedule' => [ 'registered_jobs' => static::scheduleJobCount(), ], ], ]; } protected static function isCoreFile($file) { $file = strtr($file, '\\', '/'); $classesDir = strtr(dirname(__DIR__), '\\', '/') . '/classes/'; if (strpos($file, $classesDir) === 0) return true; $distCore = strtr(dirname(__DIR__), '\\', '/') . '/dist/core.php'; return $file === $distCore; } protected static function allTraits(\ReflectionClass $ref) { $traits = []; foreach ($ref->getTraitNames() as $name) { $traits[] = $name; } $parent = $ref->getParentClass(); if ($parent) { $traits = array_merge($traits, static::allTraits($parent)); } return array_unique($traits); } protected static function runtimeDependencyCount() { $path = dirname(__DIR__) . DIRECTORY_SEPARATOR . 'composer.json'; $json = @file_get_contents($path); if (!$json) return 0; $composer = json_decode($json, true); if (!is_array($composer)) return 0; $requires = isset($composer['require']) && is_array($composer['require']) ? $composer['require'] : []; $count = 0; foreach (array_keys($requires) as $package) { $name = strtolower((string) $package); if ($name === 'php') continue; if (strpos($name, 'ext-') === 0) continue; $count++; } return $count; } protected static function hasRouteExtension($method) { return in_array($method, static::extensions('Route'), true); } protected static function cacheDriverName() { if (!class_exists('Cache')) return ''; try { $ref = new \ReflectionClass('Cache'); if (!$ref->hasProperty('driver')) return ''; $prop = $ref->getProperty('driver'); $prop->setAccessible(true); $driver = $prop->getValue(); if (!is_object($driver)) return ''; $class = get_class($driver); $parts = explode('\\', $class); return strtolower(end($parts)); } catch (\Throwable $e) { return ''; } } protected static function scheduleJobCount() { if (!class_exists('Schedule')) return 0; return count(Schedule::all()); } }class Negotiation { protected $list; public static function parse($query){ $list = new \SplPriorityQueue(); array_map(function($e) use ($list) { preg_match_all('(([^;]+)(?=\s*;\s*(\w+)\s*=\s*([^;]+))*)',$e,$p); $params = array_map('trim',array_merge( [ 'type' => current($p[0]) ], array_combine($p[2], $p[3])) ); unset($params['']); $params['q'] = isset($params['q']) ? 1.0*$params['q'] : $params['q'] = 1.0; $list->insert($params, $params['q']); },preg_split('(\s*,\s*)', $query)); return array_values(iterator_to_array($list)); } public static function bestMatch($acceptables, $choices) { return (new self($acceptables))->best($choices); } public function __construct($query) { $this->list = self::parse(trim($query)); } public function preferred(){ return self::encodeParsedValue(current($this->list)); } protected static function encodeParsedValue($parsed){ unset($parsed['q']); $type = $parsed['type']; unset($parsed['type']); return implode(';', array_merge([$type], array_map(function($k,$v){ return "$k=$v"; }, array_keys($parsed), $parsed))); } public function best($choices){ $_choices = self::parse(trim($choices)); foreach ($this->list as $accept){ foreach ($_choices as $choice){ if (preg_match('('.strtr($accept["type"], [ '.' => '\.', '+' => '\+', '*' => '.+' ] ).')', $choice["type"])){ return self::encodeParsedValue($choice); } } } return false; } }class Options extends Dictionary { protected static $fields = null; public static function loadPHP($filepath,$prefix_path=null){ ob_start(); $results = include($filepath); ob_end_clean(); if($results) { $results = static::filterWith(["load.php", "load"], $results); static::loadArray($results,$prefix_path); } } public static function loadINI($filepath,$prefix_path=null){ $results = parse_ini_file($filepath,true); if($results) { $results = static::filterWith(["load.ini", "load"], $results); static::loadArray($results,$prefix_path); } } public static function loadJSON($filepath,$prefix_path=null){ $data = file_get_contents($filepath); $results = $data?json_decode($data,true):[]; if($results) { $results = static::filterWith(["load.json", "load"], $results); static::loadArray($results,$prefix_path); } } public static function loadArray(array $array,$prefix_path=null){ $array = static::filterWith(["load.array", "load"], $array); if ($prefix_path){ static::set($prefix_path,$array); } else { static::merge($array); } self::trigger('loaded'); } public static function loadENV($dir,$envname='.env',$prefix_path=null){ $dir = rtrim($dir,'/'); $results = []; foreach(file("$dir/$envname", FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES) as $line){ $line = trim($line); if ($line[0]=='#' || strpos($line,'=')===false) continue; list($key,$value) = explode('=',$line,2); $key = trim(str_replace(['export ', "'", '"'], '', $key)); $value = stripslashes(trim($value,'"\'')); $results[$key] = preg_replace_callback('/\${([a-zA-Z0-9_]+)}/',function($m) use (&$results){ return isset($results[$m[1]]) ? $results[$m[1]] : ''; },$value); putenv("$key={$results[$key]}"); $_ENV[$key] = $results[$key]; } if($results) { $results = static::filterWith(["load.env", "load"], $results); static::loadArray($results,$prefix_path); } } }class Password { use Module; public static function make($password){ if (!defined('PASSWORD_DEFAULT')) { return '$5h$'.hash('sha1',$password); } else { return password_hash($password,PASSWORD_BCRYPT,['cost' => 12]); } } public static function verify($password, $hash){ if (!defined('PASSWORD_DEFAULT') || substr($hash,0,4)=='$5h$') { return '$5h$'.hash('sha1',$password) == $hash; } else { return password_verify($password,$hash); } } public static function compare($a, $b){ return hash_equals($a, $b); } } if(!function_exists('hash_equals')) { function hash_equals($a, $b) { return substr_count("$a" ^ "$b", "\0") * 2 === strlen("$a$b"); } }trait Persistence { public static function persistenceOptions($options=null){ static $_options = []; $class = get_called_class(); if (!isset($_options[$class])) { $_options[$class] = ['table'=>null,'key'=>'id']; } $opts =& $_options[$class]; if ($options === null) { if (empty($opts['table'])) { $defaults = static::persistenceDefaultOptionsFor($class); $opts['table'] = $defaults['table']; if (empty($opts['key'])) $opts['key'] = $defaults['key']; } return $opts; } if (is_array($options)) { foreach ($opts as $key => &$value) { if (isset($options[$key])) $value = $options[$key]; } if (empty($opts['table'])) { $defaults = static::persistenceDefaultOptionsFor($class); $opts['table'] = $defaults['table']; if (empty($opts['key'])) $opts['key'] = $defaults['key']; } return $opts; } else { if (empty($opts['table'])) { $defaults = static::persistenceDefaultOptionsFor($class); $opts['table'] = $defaults['table']; if (empty($opts['key'])) $opts['key'] = $defaults['key']; } return isset($opts[$options]) ? $opts[$options] : ''; } } private static function persistenceDefaultOptionsFor($class){ if (defined("$class::_PRIMARY_KEY_")){ $x = explode('.', $class::_PRIMARY_KEY_); return [ 'table' => current($x), 'key' => isset($x[1]) ? $x[1] : 'id', ]; } switch (substr($s = strtolower($class), -1)) { case 'y': $table = substr($s, 0, -1) . 'ies'; break; case 's': $table = substr($s, 0, -1) . 'es'; break; default: $table = $s . 's'; break; } return [ 'table' => $table, 'key' => 'id', ]; } protected static function persistenceSave(callable $callback=null){ static $save_cb = null; return $callback ? $save_cb = $callback : $save_cb; } protected static function persistenceLoad(callable $callback=null){ static $retrieve_cb = null; return $callback ? $retrieve_cb = $callback : $retrieve_cb; } public static function persistOn($table, array $options=[]){ $options['table'] = $table; static::persistenceOptions($options); } public static function onSave(callable $callback){ static::persistenceSave($callback); } public static function onLoad(callable $callback){ static::persistenceLoad($callback); } public static function load($pk){ $table = static::persistenceOptions('table'); $cb = static::persistenceLoad(); $op = static::persistenceOptions(); return ( false == is_callable($cb) ) ? static::persistenceLoadDefault($pk,$table,$op) : $cb($pk,$table,$op); } private static function persistenceLoadDefault($pk, $table, $options){ if ( $data = SQL::single("SELECT * FROM $table WHERE {$options['key']}=? LIMIT 1",[$pk]) ){ $obj = new static; foreach ((array)$data as $key => $value) { $obj->$key = $value; } if (is_callable(($c=get_called_class())."::trigger")) $c::trigger("load", $obj, $table, $options['key']); return $obj; } else { return null; } } public function save(){ $table = static::persistenceOptions('table'); $op = static::persistenceOptions(); $cb = static::persistenceSave(); $cb = $cb ? Closure::bind($cb, $this) : [$this,'persistenceSaveDefault']; return $cb($table,$op); } private function persistenceSaveDefault($table,$options){ if (is_callable(($c=get_called_class())."::trigger")) $c::trigger("save", $this, $table, $options['key']); $id = SQL::insertOrUpdate($table,array_filter((array)$this, function($var) { return !is_null($var); }),$options['key']); if (null !== $id && is_a($this, 'Model')) $this->{$options['key']} = $id; return $id; } }class REST { public static function expose($element, ?array $maps=null){ if(null === $maps && is_array($element)){ $maps = $element; $collection = ''; } else { $collection = '/'.$element; } return Route::group($collection,function() use ($maps){ $actions = []; if(isset($maps['list'])) $actions['get'] = $maps['list']; if(isset($maps['create'])) $actions['post'] = $maps['create']; if(isset($maps['clear'])) $actions['delete'] = $maps['clear']; Route::map('/',$actions); $actions = []; if(isset($maps['read'])) $actions['get'] = $maps['read']; if(isset($maps['update'])) $actions['put'] = $maps['update']; if(isset($maps['delete'])) $actions['delete'] = $maps['delete']; Route::map("/:id",$actions); }); } }class RateLimiter { use Module; protected static $local = []; public static function check(string $key, int $limit, int $window){ $window = max(1, $window); $now = time(); $entry = static::getEntry($key, $window, $now); if ($now > $entry['reset']) { $entry = [ 'count' => 0, 'reset' => $now + $window, ]; } $entry['count']++; $allowed = $entry['count'] <= $limit; static::storeEntry($key, $entry, $window); return [ 'allowed' => $allowed, 'remaining' => max(0, $limit - $entry['count']), 'reset' => $entry['reset'], ]; } public static function applyHeaders(int $limit, int $remaining, int $reset){ Response::header('X-RateLimit-Limit', (string)$limit); Response::header('X-RateLimit-Remaining', (string)$remaining); Response::header('X-RateLimit-Reset', (string)$reset); } public static function defaultKey(){ $mode = Options::get('core.security.rate_limit.key', 'ip:route'); $ip = Request::IP(); $route = Request::URI(); $method = Request::method(); switch ($mode) { case 'ip': return "{$ip}"; case 'route': return "{$method}:{$route}"; case 'ip:route': default: return "{$ip}:{$method}:{$route}"; } } protected static function getEntry(string $key, int $window, int $now){ $cacheKey = "rate:" . $key; try { return Cache::get($cacheKey, function () use ($window, $now) { return [ 'count' => 0, 'reset' => $now + $window, ]; }, $window); } catch (Throwable $e) { if (!isset(static::$local[$cacheKey])) { static::$local[$cacheKey] = [ 'count' => 0, 'reset' => $now + $window, ]; } return static::$local[$cacheKey]; } } protected static function storeEntry(string $key, array $entry, int $window){ $cacheKey = "rate:" . $key; try { Cache::set($cacheKey, $entry, $window); } catch (Throwable $e) { static::$local[$cacheKey] = $entry; } } }class Redirect { use Module; public static function to($url, $status=302){ if ($link = Filter::with('core.redirect',$url)) { Response::clean(); Response::status($status); Response::header('Location', $link); Response::send(); exit; } } public static function back(){ if ($link = Filter::with('core.redirect', (empty($_SERVER['HTTP_REFERER']) ? Request::get('redirect_uri',false) : $_SERVER['HTTP_REFERER']) )){ Response::clean(); Response::header('Location', $link); Response::send(); exit; } } public static function viaJavaScript($url, $parent=false){ if ($link = Filter::with('core.redirect', $url)){ Response::type('text/html'); Response::add('<script>'.($parent?'parent.':'').'location.href="'.addslashes($link).'"</script>'); Response::send(); exit; } } }trait Relation { protected static function & relationOptions(){ static $_options; if ($_options === null) $_options = (object)[ 'links' => [], 'relations' => [] ]; return $_options; } private static function relationAddRelationshipTo($link, $plurality, $extra=[]){ $options = static::relationOptions(); preg_match('((?<FOREIGN_CLASS>\w+)(\.(?<FOREIGN_KEY>\w+))?(:(?<LOCAL_KEY>\w+))?)', $link, $parts); $foreign_class = isset($parts['FOREIGN_CLASS']) ? $parts['FOREIGN_CLASS'] : false; $foreign_key = isset($parts['FOREIGN_KEY']) ? $parts['FOREIGN_KEY'] : false; $local_key = isset($parts['LOCAL_KEY']) ? $parts['LOCAL_KEY'] : false; if ( ! $foreign_class ) throw new Exception("[Core.Relation] Class ".get_called_class()." must define a foreign Model when assigning a relation.", 1); if ( ! is_subclass_of($foreign_class,"Model") ) throw new Exception("[Core.Relation] Class ".get_called_class()." want to relate to $foreign_class but it's not a Model.", 1); if ( ! $foreign_key ) { $foreign_key = $foreign_class::persistenceOptions("key"); } if ( ! $local_key ) { $local_key = static::persistenceOptions("key"); } $single = $plurality == 'single'; $method = preg_replace_callback('([A-Z])', function($m){ return "_" . strtolower($m[0]); }, lcfirst($foreign_class) . ($single ? '' : 's')); $hh = [$foreign_class,$foreign_key,$local_key]; sort($hh); $options->links[md5(serialize($hh))] = $rel = (object)[ 'foreign_class' => $foreign_class, 'foreign_key' => $foreign_key, 'local_key' => $local_key, 'single' => $single, 'method' => $method, 'extra' => (object) $extra, ]; if (empty($options->relations)) $options->relations = (object)[]; $options->relations->$method = $getset = (object)[ 'get' => function($self) use ($foreign_class, $rel) { $val = $self->{$rel->local_key}; if ($val === null) { $data = $foreign_class::where("{$rel->foreign_key} IS NULL"); } else { $val = is_numeric($val) ? $val : "'" . addslashes((string)$val) . "'"; $data = $foreign_class::where("{$rel->foreign_key} = {$val}"); } return $rel->single ? current($data) : $data; }, 'set' => function($value, $self) use ($foreign_class, $rel) { if (!is_a($value, $foreign_class)) throw new Exception("[Core.Relation] Relationship for {$rel->method} must be of class $foreign_class.", 1); $self->local_key = $value->foreign_key; return $value; }, ]; } public function __get($name){ $options = static::relationOptions(); if (isset($options->relations->$name)) return call_user_func($options->relations->$name->get, $this); } public function __set($name, $value){ $options = static::relationOptions(); if (isset($options->relations->$name)) call_user_func($options->relations->$name->set, $value, $this); } public function __isset($name){ $options = static::relationOptions(); return isset($options->relations->$name); } public static function hasOne($modelName, $extra=[]){ return static::relationAddRelationshipTo($modelName, 'single', $extra); } public static function hasMany($modelName, $extra=[]){ return static::relationAddRelationshipTo($modelName, 'multiple', $extra); } }#[\AllowDynamicProperties] abstract class Model implements JsonSerializable { use Module, Persistence, Events, Relation; public static function where($where_sql = false, $params = [], $flush = false){ $key = static::persistenceOptions('key'); return SQL::reduce("SELECT {$key} FROM " . static::persistenceOptions('table') . ($where_sql ? " where {$where_sql}" : ''), $params, function($results, $row) use ($key) { $results[] = static::load($row->{$key}); return $results; }, []); } public static function count($where_sql = false, $params = []) { return (int) SQL::value('SELECT COUNT(1) FROM ' . static::persistenceOptions('table') . ($where_sql ? " where {$where_sql}" : ''), $params); } public static function all($page=1, $limit=-1){ return static::where($limit < 1 ? "" : "1 limit {$limit} offset " . (max(1,$page)-1)*$limit); } public function primaryKey(){ $key = static::persistenceOptions('key'); return $this->{$key}; } public static function create($data){ $tmp = new static; $data = (object)$data; foreach (array_keys(get_object_vars($tmp)) as $key) { if (isset($data->{$key})) $tmp->{$key} = $data->{$key}; } $tmp->save(); static::trigger('create',$tmp,$data); return $tmp; } public function export($transformer=null, $disabled_relations=[]){ $data = []; if (!is_callable($transformer)) $transformer = function($k,$v){ return [$k=>$v]; }; foreach (get_object_vars($this) as $key => $value) { if ($res = $transformer($key, $value)){ $data[key($res)] = current($res); } } foreach (static::relationOptions()->links as $hash => $link) { $relation = $link->method; if (isset($disabled_relations[$hash])) continue; $disabled_relations[$hash] = true; $value = $this->$relation; if ($value && is_array($value)) foreach ($value as &$val) $val = $val->export(null,$disabled_relations); else $value = $value ? $value->export(null,$disabled_relations) : false; unset($disabled_relations[$hash]); if ($res = $transformer($relation, $value)){ $data[key($res)] = current($res); } } return $data; } public function jsonSerialize(): mixed { return $this->export(); } public static function schema() { return Schema::describe(static::persistenceOptions('table')); } public static function fields() { return Schema::columns(static::persistenceOptions('table')); } }class Job extends Model { const _PRIMARY_KEY_ = "queue.id"; public $id, $type, $status = 'PENDING', $tries = 0, $created_at, $scheduled_at, $activated_at, $payload, $error; public static function queue($type, $payload=null, $when=null){ $now = gmdate("Y-m-d H:i:s"); $job = new static; $job->type = $type; $job->created_at = $now; $job->scheduled_at = $when ? gmdate("Y-m-d H:i:s",(is_int($when) ? $when : (strtotime($when)?:time()))) : $now; $job->payload = $payload !== null ? serialize($payload) : null; $job->save(); } public static function register($type, $callback){ self::on("worker[{$type}]", $callback); } public static function cleanQueue($all=false){ $statuses = $all ? "'DONE','ERROR'" : "'DONE'"; return SQL::exec("DELETE FROM `".static::persistenceOptions('table')."` WHERE `status` IN ($statuses)"); } public static function execute(){ $condition = "status = 'PENDING' and `scheduled_at` <= NOW() ORDER BY `scheduled_at` ASC LIMIT 1"; if (($job = static::where($condition)) && ($job = current($job))){ SQL::update(static::persistenceOptions('table'),['id' => $job->id, 'status' => 'ACTIVE']); $job->run(); return $job; } else return false; } public function run(){ $this->status = 'ACTIVE'; $this->activated_at = gmdate("Y-m-d H:i:s"); $this->tries++; $this->save(); $this->status = 'DONE'; self::trigger("worker[{$this->type}]", $this, $this->payload ? unserialize($this->payload) : null); $this->save(); } public function error($message=null){ $this->status = 'ERROR'; $this->error = $message; } public function retry($message=null){ $this->status = 'PENDING'; $this->error = $message; } }class Request { use Module; protected static $body, $accepts; public static function accept($key='type',$choices='') { if (null === static::$accepts) static::$accepts = [ 'type' => new Negotiation(isset($_SERVER['HTTP_ACCEPT']) ? $_SERVER['HTTP_ACCEPT'] : ''), 'language' => new Negotiation(isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] : ''), 'encoding' => new Negotiation(isset($_SERVER['HTTP_ACCEPT_ENCODING']) ? $_SERVER['HTTP_ACCEPT_ENCODING'] : ''), 'charset' => new Negotiation(isset($_SERVER['HTTP_ACCEPT_CHARSET']) ? $_SERVER['HTTP_ACCEPT_CHARSET'] : ''), ]; return empty(static::$accepts[$key]) ? false : ( empty($choices) ? static::$accepts[$key]->preferred() : static::$accepts[$key]->best($choices) ); } public static function input($key=null,$default=null){ return $key ? (isset($_REQUEST[$key]) ? new Structure($_REQUEST[$key]) : (is_callable($default)?call_user_func($default):$default)) : new Structure($_REQUEST); } public static function env($key=null,$default=null){ return $key ? (filter_input(INPUT_ENV,$key) ?: (is_callable($default)?call_user_func($default):$default)) : $_ENV; } public static function server($key=null,$default=null){ return $key ? (isset($_SERVER[$key]) ? $_SERVER[$key] : (is_callable($default)?call_user_func($default):$default)) : $_SERVER; } public static function post($key=null,$default=null){ return $key ? (filter_input(INPUT_POST,$key) ?: (is_callable($default)?call_user_func($default):$default)) : $_POST; } public static function get($key=null,$default=null){ return $key ? (filter_input(INPUT_GET,$key) ?: (is_callable($default)?call_user_func($default):$default)) : $_GET; } public static function files($key=null,$default=null){ return $key ? (isset($_FILES[$key]) ? $_FILES[$key] : (is_callable($default)?call_user_func($default):$default)) : $_FILES; } public static function cookie($key=null,$default=null){ return $key ? (filter_input(INPUT_COOKIE,$key) ?: (is_callable($default)?call_user_func($default):$default)) : $_COOKIE; } public static function host($with_protocol=true){ switch(true){ case !empty($_SERVER['HTTP_X_FORWARDED_HOST']) : $host = trim(substr(strrchr($_SERVER['HTTP_X_FORWARDED_HOST'],','),1) ?: $_SERVER['HTTP_X_FORWARDED_HOST']); break; case !empty($_SERVER['HTTP_HOST']) : $host = $_SERVER['HTTP_HOST']; break; case !empty($_SERVER['SERVER_NAME']) : $host = $_SERVER['SERVER_NAME']; break; case !empty($_SERVER['HOSTNAME']) : $host = $_SERVER['HOSTNAME']; break; default : $host = 'localhost'; break; } $host = explode(':',$host,2); $port = isset($host[1]) ? (int)$host[1] : (isset($_SERVER['SERVER_PORT'])?$_SERVER['SERVER_PORT']:80); $host = $host[0] . (($port && $port != 80) ? ":$port" : ''); if ($port == 80) $port = ''; return ($with_protocol ? 'http' . (!empty($_SERVER['HTTPS'])&&(strtolower($_SERVER['HTTPS'])!=='off')?'s':'') . '://' : '') . Filter::with('core.request.host',$host); } public static function URL(){ return static::host(true) . static::URI(); } public static function header($key=null,$default=null){ if ($key) $key = 'HTTP_'.strtr(strtoupper($key),'-','_'); return $key ? (isset($_SERVER[$key])? $_SERVER[$key] : (is_callable($default)?call_user_func($default):$default)) : array_filter($_SERVER, function($k) { return strrpos($k, "HTTP_") === 0; }, ARRAY_FILTER_USE_KEY); } public static function URI(){ switch(true){ case !empty($_SERVER['REQUEST_URI']): $serv_uri = $_SERVER['REQUEST_URI']; break; case !empty($_SERVER['ORIG_PATH_INFO']): $serv_uri = $_SERVER['ORIG_PATH_INFO']; break; case !empty($_SERVER['PATH_INFO']): $serv_uri = $_SERVER['PATH_INFO']; break; default: $serv_uri = '/'; break; } $uri = rtrim(strtok($serv_uri,'?'),'/') ?: '/'; return Filter::with('core.request.URI', $uri) ?: '/'; } public static function baseURI(){ return dirname(empty($_SERVER['SCRIPT_NAME']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME']) ?: '/'; } public static function method(){ return Filter::with('core.request.method',strtolower(empty($_SERVER['REQUEST_METHOD'])?'get':$_SERVER['REQUEST_METHOD'])); } public static function IP(){ switch(true){ case !empty($_SERVER['HTTP_X_FORWARDED_FOR']): $ip = trim(substr(strrchr($_SERVER['HTTP_X_FORWARDED_FOR'],','),1) ?: $_SERVER['HTTP_X_FORWARDED_FOR']); break; case !empty($_SERVER['HTTP_X_FORWARDED_HOST']): $ip = trim(substr(strrchr($_SERVER['HTTP_X_FORWARDED_HOST'],','),1) ?: $_SERVER['HTTP_X_FORWARDED_HOST']); break; case !empty($_SERVER['REMOTE_ADDR']): $ip = $_SERVER['REMOTE_ADDR']; break; case !empty($_SERVER['HTTP_CLIENT_IP']): $ip = $_SERVER['HTTP_CLIENT_IP']; break; default: $ip = ''; break; } return Filter::with('core.request.IP',$ip); } public static function UA(){ return Filter::with('core.request.UA',strtolower(empty($_SERVER['HTTP_USER_AGENT'])?'':$_SERVER['HTTP_USER_AGENT'])); } public static function data($key=null,$default=null){ if (null===static::$body){ $json = (false !== stripos(empty($_SERVER['HTTP_CONTENT_TYPE'])?'':$_SERVER['HTTP_CONTENT_TYPE'],'json')) || (false !== stripos(empty($_SERVER['CONTENT_TYPE'])?'':$_SERVER['CONTENT_TYPE'],'json')); if ($json) { static::$body = json_decode(file_get_contents("php://input")); } else { if (empty($_POST)) { static::$body = file_get_contents("php://input"); } else { static::$body = (object)$_POST; } } } return $key ? (isset(static::$body->$key) ? static::$body->$key : (is_callable($default)?call_user_func($default):$default)) : static::$body; } }abstract class Resource implements JsonSerializable { public $fields, $projector, $exposed; public static $PKEY = 'id', $exposureMode = 'full'; public function __construct($row, $projector = null){ $this->projector = $projector ?: static::buildProjector(); $this->fields = (object)$row; } public function __get($n){ if ($this->exposed === null) $this->exposed[static::$exposureMode] = $this->jsonSerialize(); return isset($this->exposed[static::$exposureMode][$n]) ? $this->exposed[static::$exposureMode][$n] : null; } public function __isset($n){ if ($this->exposed === null) $this->exposed[static::$exposureMode] = $this->jsonSerialize(); return isset($this->exposed[static::$exposureMode][$n]); } public function jsonSerialize(): mixed{ return call_user_func($this->projector,$this->expose($this->fields, static::$exposureMode)); } abstract public function expose($fields, $mode); public static function buildProjector(){ if ($projection_fields = Filter::with([ "api.".get_called_class().".getProjectionFields", "api.resource.getProjectionFields", ],Request::get('fields'))) { $projection_fields = preg_split('~\s*,\s*~', $projection_fields); array_unshift($projection_fields, static::$PKEY); $projection_fields = array_unique($projection_fields); $projector = function($element) use ($projection_fields) { $unique_placeholder = '@___CO('.time().')RE___@'; $field_get = function ($x, $path, $default=null){ $current = (array)$x; $p = strtok($path, '.'); while (isset($current[$p])) { if (!$p = strtok('.')) return $current; $current = (array)$current[$p]; } return $default; }; $field_set = function (&$x, $path, $value){ $current = $x; $p = strtok($path, '.'); while ($p !== false) { $p = strtok('.'); if (!isset($current[$p])) $current[$p]=[]; $current = (array)$current[$p]; } return $current; }; $element = (object) $element; $obj = []; foreach ($projection_fields as $field_path) { if (isset($element->$field_path)){ $obj[$field_path] = $element->$field_path; } else { if (($value = $field_get($element, $field_path, $unique_placeholder)) !== $unique_placeholder){ var_dump($value, $element, $field_path, $unique_placeholder); $field_set($obj, $field_path, $value); } } } return (object) $obj; }; } else { $projector = function($x){ return $x; }; } return $projector; } public static function setExposure($exposureMode){ return static::$exposureMode = $exposureMode; } public static function fromSQL($sql, $params=[]){ return Collection::fromSQL(get_called_class(), $sql, $params); } public static function singleFromSQL($sql, $params=[]){ return ($data = SQL::single($sql, $params)) ? new static($data) : false; } }class Response { use Module, Events; const TYPE_JSON = 'application/json', TYPE_HTML = 'text/html', TYPE_TEXT = 'text/plain', TYPE_CSS = 'text/css', TYPE_XML = 'text/xml', TYPE_SVG = 'image/svg+xml', TYPE_JS = 'application/javascript', TYPE_BIN = 'application/octet-stream'; protected static $payload = [], $status = 200, $charset = "utf-8", $headers = ['Content-Type' => ['text/html; charset=utf-8']], $buffer = null, $force_dl = false, $link = null, $sent = false, $links = []; public static function charset($charset){ static::$charset = $charset; } public static function type($mime){ static::header('Content-Type',$mime . (static::$charset ? '; charset='.static::$charset : '')); } public static function download($data){ if (is_array($data)) { if (isset($data['filename'])) static::$force_dl = $data['filename']; if (isset($data['charset'])) static::charset($data['charset']); if (isset($data['mime'])) static::type($data['mime']); if (isset($data['body'])) static::body($data['body']); } else static::$force_dl = $data; } public static function start(){ static::$buffer = ob_start(); } public static function enableCORS($origin='*'){ if ($origin = $origin ?:( isset($_SERVER['HTTP_ORIGIN']) ? $_SERVER['HTTP_ORIGIN'] : (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '*') )) { static::header('Access-Control-Allow-Origin', $origin); static::header('Access-Control-Allow-Credentials', 'true'); static::header('Access-Control-Max-Age', 86400); } if (filter_input(INPUT_SERVER,'REQUEST_METHOD') == 'OPTIONS') { static::clean(); if (filter_input(INPUT_SERVER,'HTTP_ACCESS_CONTROL_REQUEST_METHOD')) { static::header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, HEAD, CONNECT, PATCH, TRACE'); } if ($req_h = filter_input(INPUT_SERVER,'HTTP_ACCESS_CONTROL_REQUEST_HEADERS')) { static::header('Access-Control-Allow-Headers',$req_h); } self::trigger('cors.preflight'); static::send(); exit; } } public static function sent() { return static::$sent; } public static function end(){ if (static::$buffer){ static::$payload[] = ob_get_contents(); ob_end_clean(); static::$buffer = null; return end(static::$payload); } } public static function isBuffering(){ return static::$buffer; } public static function clean(){ static::$payload = []; static::$headers = []; } public static function reset(){ static::$payload = []; static::$status = 200; static::$charset = "utf-8"; static::$headers = ['Content-Type' => ['text/html; charset=utf-8']]; static::$buffer = null; static::$force_dl = false; static::$link = null; static::$sent = false; static::$links = []; } public static function json($payload){ static::type(static::TYPE_JSON); static::$payload[] = json_encode($payload, Options::get('core.response.json_flags',JSON_NUMERIC_CHECK|JSON_BIGINT_AS_STRING)); } public static function text(...$args){ static::type(static::TYPE_TEXT); static::$payload[] = implode('',$args); } public static function xml(...$args){ static::type(static::TYPE_XML); static::$payload[] = implode('', $args); } public static function svg(...$args){ static::type(static::TYPE_SVG); static::$payload[] = implode('', $args); } public static function html(...$args){ static::type(static::TYPE_HTML); static::$payload[] = implode('', $args); } public static function add(){ foreach(func_get_args() as $data){ switch (true) { case is_callable($data) : return static::add($data()); case is_a($data, 'View') : return static::$payload[] = "$data"; case is_object($data) || is_array($data) || is_bool($data): return static::json($data); default: return static::$payload[] = $data; } } } public static function status($code,$message=''){ static::header('Status',$message?:$code,$code); } public static function header($name,$value,$code=null){ if (empty(static::$headers[$name])){ static::$headers[$name] = [[$value,$code]]; } else { static::$headers[$name][] = [$value,$code]; } } public static function error($code=500,$message='Application Error'){ static::trigger('error',$code,$message); Event::trigger('core.response.error',$code,$message); static::status($code,$message); } public static function body($setBody=null){ if ($setBody) static::$payload = [$setBody]; return Filter::with('core.response.body', is_array(static::$payload) ? implode('',static::$payload) : static::$payload ); } public static function headers($setHeaders=null){ if ($setHeaders) static::$headers = $setHeaders; return static::$headers; } public static function save(){ return [ 'head' => static::$headers, 'body' => static::body(), ]; } public static function load($data){ $data = (object)$data; if (isset($data->head)) static::headers($data->head); if (isset($data->body)) static::body($data->body); } public static function send($force = false){ if (!static::$sent || $force) { static::$sent = true; static::trigger('send'); Event::trigger('core.response.send'); if (false === headers_sent()) foreach (static::$headers as $name => $family) foreach ($family as $value_code) { if (is_array($value_code)) { list($value, $code) = (count($value_code) > 1) ? $value_code : [current($value_code), 200]; } else { $value = $value_code; $code = null; } switch($value){ case "Status": if (function_exists('http_response_code')){ http_response_code($code); } else { header("Status: $code", true, $code); } break; case "Link": header("Link: $value", false); break; default: if ($code) { header("$name: $value", true, $code); } else { header("$name: $value", true); } break; } } if (static::$force_dl) header('Content-Disposition: attachment; filename="'.static::$force_dl.'"'); echo static::body(); static::trigger('sent'); } } public static function push($links, $type='text'){ if (is_array($links)){ foreach($links as $_type => $link) { if (is_numeric($_type)) switch(strtolower(substr(strrchr(strtok(basename($link),'?'),'.'),1))) { case 'js': $_type = 'script'; break; case 'css': $_type = 'style'; break; case 'png': case 'svg': case 'gif': case 'jpg': $_type = 'image'; break; case 'woff': case 'woff2': case 'ttf': case 'eof': $_type = 'font'; break; default: $_type = 'text'; break; } foreach ((array)$link as $link_val) { static::header("Link","<$link_val>; rel=preload; as=$_type"); } } } else { static::header("Link","<".((string)$links).">; rel=preload; as=$type"); } } }class Route { use Module, Events { on as onEvent; } public static $routes, $base = '', $prefix = [], $group = [], $tags = [], $optimized_tree = [], $compiled_tree = null, $compiled_dispatcher = null, $compiled = false, $stats = [ 'dispatch' => 0, 'matched' => 0, 'unmatched' => 0, 'static_checks' => 0, 'dynamic_checks' => 0, 'static_hit' => 0, 'dynamic_hit' => 0, 'regex_checks' => 0, 'depth_total' => 0, 'depth_max' => 0, ]; protected $URLPattern = '', $pattern = '', $matcher_pattern = '', $dynamic = false, $callback = null, $methods = [], $befores = [], $afters = [], $rules = [], $response = '', $tag = ''; public function __construct($URLPattern, $callback = null, $method='get'){ $prefix = static::$prefix ? rtrim(implode('',static::$prefix),'/') : ''; $pattern = '/' . trim($URLPattern, "/"); $this->callback = $callback; $this->URLPattern = str_replace('//','/',str_replace('/(','(/', rtrim("{$prefix}{$pattern}","/"))); $this->dynamic = $this->isDynamic($this->URLPattern); $this->pattern = $this->dynamic ? $this->compilePatternAsRegex($this->URLPattern, $this->rules) : $this->URLPattern; $this->matcher_pattern = $this->dynamic ? $this->compilePatternAsRegex($this->URLPattern, $this->rules, false) : ''; $this->methods[$method] = 1; return static::add($this); } public function match($URL, $method='get'){ $method = strtolower($method); if (empty($this->methods[$method]) && empty($this->methods['*'])) return false; return (bool) ( $this->dynamic ? preg_match($this->matcher_pattern, '/'.trim($URL,'/')) : rtrim($URL,'/') == rtrim($this->pattern,'/') ); } public static function reset(){ static::$routes = []; static::$base = ''; static::$prefix = []; static::$group = []; static::$optimized_tree = []; static::$compiled_tree = null; static::$compiled_dispatcher = null; static::$compiled = false; static::$stats = [ 'dispatch' => 0, 'matched' => 0, 'unmatched' => 0, 'static_checks' => 0, 'dynamic_checks' => 0, 'static_hit' => 0, 'dynamic_hit' => 0, 'regex_checks' => 0, 'depth_total' => 0, 'depth_max' => 0, ]; } public static function compile(){ $root = static::compiledNode(); $routes = []; $static_map = []; $dynamic_list = []; foreach ((array)static::$routes as $group => $list){ foreach ((array)$list as $route) { if (is_a($route, __CLASS__)) $routes[] = $route; } } foreach ($routes as $route) { if ($route->dynamic) { static::collectDynamicRoute($dynamic_list, $route); static::insertDynamicRoute($root, $route); } else { static::collectStaticRoute($static_map, $route); static::insertStaticRoute($root, $route); } } static::sortDynamicRoutes($root); static::$compiled_tree = $root; static::$compiled_dispatcher = static::buildDispatcher($static_map, $dynamic_list); static::$compiled = true; return static::$compiled_dispatcher; } public static function stats(){ return static::$stats; } public static function debugTree(){ $tree = static::$compiled_tree; if (!$tree) { return [ 'compiled' => false, 'routes' => static::countRoutes(), ]; } return [ 'compiled' => true, 'routes' => static::countRoutes(), 'tree' => static::debugNode($tree), ]; } protected static function compiledNode(){ return [ 'static' => [], 'dynamic_routes' => [], 'routes' => [], ]; } protected static function countRoutes(){ $count = 0; foreach ((array)static::$routes as $group => $list){ foreach ((array)$list as $route) { if (is_a($route, __CLASS__)) $count++; } } return $count; } protected static function debugNode($node){ $children = []; foreach ($node['static'] as $seg => $child) { $children[$seg] = static::debugNode($child); } return [ 'static_children' => count($node['static']), 'dynamic_routes' => count($node['dynamic_routes']), 'routes' => count($node['routes']), 'children' => $children, ]; } protected static function insertStaticRoute(array &$root, $route){ $segments = array_filter(explode('/', trim($route->URLPattern,'/')), 'strlen'); $node =& $root; foreach ($segments as $seg) { if (!isset($node['static'][$seg])) $node['static'][$seg] = static::compiledNode(); $node =& $node['static'][$seg]; } $node['routes'][] = $route; } protected static function insertDynamicRoute(array &$root, $route){ $segments = array_filter(explode('/', trim($route->URLPattern,'/')), 'strlen'); $prefix = []; foreach ($segments as $seg) { if (static::isDynamic($seg) || strpos($seg,'(') !== false) break; $prefix[] = $seg; } $node =& $root; foreach ($prefix as $seg) { if (!isset($node['static'][$seg])) $node['static'][$seg] = static::compiledNode(); $node =& $node['static'][$seg]; } $dynamic_count = 0; foreach ($segments as $seg) { if (static::isDynamic($seg) || strpos($seg,'(') !== false) $dynamic_count++; } $specificity = ((count($segments) - $dynamic_count) * 100) + strlen($route->URLPattern); $node['dynamic_routes'][] = [ 'route' => $route, 'matcher' => $route->matcher_pattern, 'methods' => $route->methods, 'specificity' => $specificity, ]; } protected static function sortDynamicRoutes(array &$node){ if (!empty($node['dynamic_routes'])) { usort($node['dynamic_routes'], function($a, $b){ return $b['specificity'] <=> $a['specificity']; }); } foreach ($node['static'] as &$child) { static::sortDynamicRoutes($child); } } protected static function collectStaticRoute(array &$static_map, $route){ $path = rtrim($route->pattern, '/') ?: '/'; foreach ($route->methods as $method => $v) { $static_map[$method][$path] = $route; } } protected static function collectDynamicRoute(array &$dynamic_list, $route){ $bucket = static::dynamicBucket($route->URLPattern); $prefix = $bucket['prefix']; $hint = $bucket['hint']; $hint_pos = $bucket['hint_pos']; foreach ($route->methods as $method => $v) { if (!isset($dynamic_list[$method])) $dynamic_list[$method] = []; $dynamic_list[$method][] = [ 'prefix' => $prefix, 'hint' => $hint, 'hint_pos' => $hint_pos, 'route' => $route, ]; } } protected static function dynamicPrefix($pattern){ $bucket = static::dynamicBucket($pattern); return $bucket['prefix']; } protected static function dynamicBucket($pattern){ $segments = array_filter(explode('/', trim($pattern,'/')), 'strlen'); $prefix = []; $found_dynamic = false; $hint = ''; $hint_pos = null; $has_optional = strpos($pattern, '(') !== false; foreach ($segments as $idx => $seg) { $is_dynamic = static::isDynamic($seg) || strpos($seg,'(') !== false; if (!$found_dynamic && !$is_dynamic) { $prefix[] = $seg; continue; } $found_dynamic = true; if ($hint === '' && !$has_optional && !$is_dynamic) { $hint = $seg; $hint_pos = $idx; break; } } return [ 'prefix' => $prefix ? '/' . implode('/', $prefix) : '', 'hint' => $hint, 'hint_pos' => $hint_pos, ]; } protected static function buildDispatcher(array $static_map, array $dynamic_list){ $static_effective = []; $wildcard = $static_map['*'] ?? []; foreach ($static_map as $method => $map) { if ($method === '*') continue; $static_effective[$method] = $map + $wildcard; } if (!empty($wildcard)) { $static_effective['*'] = $wildcard; } $dispatcher = [ 'static' => $static_map, 'static_effective' => $static_effective, 'dynamic' => [], ]; $chunk = 20; foreach ($dynamic_list as $method => $list) { if (!empty($list)) { $hint_counts = []; foreach ($list as $entry) { if (empty($entry['hint'])) continue; $key = $entry['prefix'] . '|' . $entry['hint_pos'] . '|' . $entry['hint']; if (!isset($hint_counts[$key])) $hint_counts[$key] = 0; $hint_counts[$key]++; } if ($hint_counts) { foreach ($list as &$entry) { if (empty($entry['hint'])) continue; $key = $entry['prefix'] . '|' . $entry['hint_pos'] . '|' . $entry['hint']; if (($hint_counts[$key] ?? 0) < 3) { $entry['hint'] = ''; $entry['hint_pos'] = null; } } unset($entry); } } foreach (static::chunkDynamicRoutes($list, $chunk) as $bundle) { $dispatcher['dynamic'][$method][] = static::buildRegexDispatcher($bundle['routes'], $bundle['prefix'], $bundle['hint'], $bundle['hint_pos']); } } return $dispatcher; } protected static function buildRegexDispatcher(array $routes, $prefix, $hint = '', $hint_pos = null){ $branches = []; $meta = []; $group_indexes = []; $group_index = 1; foreach ($routes as $idx => $route) { $regex = static::compilePatternAsRegexNoNames($route->URLPattern, $route->rules); $inner = static::regexInner($regex); $key = '__r' . $idx; $param_index = []; $param_names = static::paramNames($route->URLPattern); $index = $group_index + 1; foreach ($param_names as $param) { $param_index[$index] = $param; $index++; } $branches[] = '(?P<' . $key . '>' . $inner . ')'; $group_indexes[] = $group_index; $meta[$group_index] = [ 'route' => $route, 'param_index' => $param_index, ]; $group_index += 1 + count($param_names); } $regex = '#^(?:' . implode('|', $branches) . ')$#'; return [ 'prefix' => $prefix, 'hint' => $hint, 'hint_pos' => $hint_pos, 'regex' => $regex, 'meta' => $meta, 'group_indexes' => $group_indexes, ]; } protected static function chunkDynamicRoutes(array $list, $chunk){ $bundles = []; $current_prefix = null; $current_hint = null; $current_hint_pos = null; $current_routes = []; foreach ($list as $entry) { $prefix = $entry['prefix']; $hint = $entry['hint'] ?? ''; $hint_pos = $entry['hint_pos'] ?? null; $key = $prefix . '|' . $hint . '|' . ($hint_pos === null ? '' : $hint_pos); $current_key = $current_prefix === null ? null : ($current_prefix . '|' . $current_hint . '|' . ($current_hint_pos === null ? '' : $current_hint_pos)); if ($current_prefix === null) { $current_prefix = $prefix; $current_hint = $hint; $current_hint_pos = $hint_pos; $current_key = $key; } if ($key !== $current_key || count($current_routes) >= $chunk) { if ($current_routes) { $bundles[] = [ 'prefix' => $current_prefix, 'hint' => $current_hint, 'hint_pos' => $current_hint_pos, 'routes' => $current_routes, ]; } $current_prefix = $prefix; $current_hint = $hint; $current_hint_pos = $hint_pos; $current_routes = []; $current_key = $key; } $current_routes[] = $entry['route']; } if ($current_routes) { $bundles[] = [ 'prefix' => $current_prefix, 'hint' => $current_hint, 'hint_pos' => $current_hint_pos, 'routes' => $current_routes, ]; } return $bundles; } protected static function regexInner($pattern){ if (str_starts_with($pattern, '#^') && str_ends_with($pattern, '$#')) { return substr($pattern, 2, -2); } $trim = trim($pattern, '#'); if (strpos($trim, '^') === 0) $trim = substr($trim, 1); if (substr($trim, -1) === '$') $trim = substr($trim, 0, -1); return $trim; } protected static function paramNames($pattern){ if (!preg_match_all(pattern: '#:([a-zA-Z]\\w*)#', subject: $pattern, matches: $m)) return []; return $m[1]; } protected static function compilePatternAsRegexNoNames($pattern, $rules=[]){ return '#^'.preg_replace_callback( pattern: '#:([a-zA-Z]\\w*)#', callback: function($g) use (&$rules){ $rule = isset($rules[$g[1]]) ? $rules[$g[1]] : '[^/]+'; $rule = static::makeNonCapturing($rule); return '(' . '(?:' . $rule . ')' . ')'; }, subject: str_replace(['.',')','*'],['\.',')?','.+'],$pattern) ).'$#'; } protected static function makeNonCapturing($pattern){ $len = strlen($pattern); $out = ''; $in_class = false; for ($i = 0; $i < $len; $i++) { $ch = $pattern[$i]; if ($ch === '\\') { $out .= $ch; if ($i + 1 < $len) { $out .= $pattern[$i + 1]; $i++; } continue; } if ($ch === '[') { $in_class = true; $out .= $ch; continue; } if ($ch === ']' && $in_class) { $in_class = false; $out .= $ch; continue; } if ($ch === '(' && !$in_class) { $next = $i + 1 < $len ? $pattern[$i + 1] : ''; if ($next === '?') { $next2 = $i + 2 < $len ? $pattern[$i + 2] : ''; if ($next2 === 'P' || $next2 === '<') { $gt = strpos($pattern, '>', $i + 3); if ($gt !== false) { $out .= '(?:'; $i = $gt; continue; } } $out .= $ch; continue; } $out .= '(?:'; continue; } $out .= $ch; } return $out; } protected static function hasListeners(string $class, ?array $names = null){ try { $getter = function() { return self::$_listeners; }; $bound = $getter->bindTo(null, $class); $listeners = (array)$bound(); } catch (Throwable $e) { return false; } if (empty($listeners)) return false; if ($names === null) return true; foreach ($names as $name) { if (!empty($listeners[$name])) return true; } return false; } protected static function hasRouteEvents(){ if (static::hasListeners(static::class, ['start','before','after','end'])) return true; return static::hasListeners(Event::class, ['core.route.before','core.route.after','core.route.end']); } protected static function hasBeforeAfter($route){ return !empty($route->befores) || !empty($route->afters); } public function run(array $args, $method='get'){ $method = strtolower($method); $append_echoed_text = Options::get('core.route.append_echoed_text',true); $fast_path = !$append_echoed_text && !static::hasBeforeAfter($this) && !static::hasRouteEvents(); if (!$fast_path) { static::trigger('start', $this, $args, $method); } if ( !$fast_path && $this->befores ) { foreach (array_reverse($this->befores) as $mw) { static::trigger('before', $this, $mw); Event::trigger('core.route.before', $this, $mw); ob_start(); $mw_result = call_user_func($mw); $raw_echoed = ob_get_clean(); if ($append_echoed_text) Response::add($raw_echoed); if ( false === $mw_result ) { return ['']; } else { Response::add($mw_result); } } } $callback = (is_array($this->callback) && isset($this->callback[$method])) ? $this->callback[$method] : $this->callback; if (is_callable($callback) || is_a($callback, "View") ) { Response::type( Options::get('core.route.response_default_type', Response::TYPE_HTML) ); ob_start(); if (is_a($callback, "View")) { $view_results = (string)$callback; } else { $view_results = call_user_func_array($callback, $args); } $raw_echoed = ob_get_clean(); if ($append_echoed_text) Response::add($raw_echoed); Response::add($view_results); } if ( !$fast_path && $this->afters ) { foreach ($this->afters as $mw) { static::trigger('after', $this, $mw); Event::trigger('core.route.after', $this, $mw); ob_start(); $mw_result = call_user_func($mw); $raw_echoed = ob_get_clean(); if ($append_echoed_text) Response::add($raw_echoed); if ( false === $mw_result ) { return ['']; } else { Response::add($mw_result); } } } if (!$fast_path) { static::trigger('end', $this, $args, $method); Event::trigger('core.route.end', $this); } return [Filter::with('core.route.response', Response::body())]; } public function runIfMatch($URL, $method='get'){ return $this->match($URL,$method) ? $this->run($this->extractArgs($URL),$method) : null; } public static function on($URLPattern, $callback = null){ return new Route($URLPattern,$callback); } public static function get($URLPattern, $callback = null){ return (new Route($URLPattern,$callback))->via('get'); } public static function post($URLPattern, $callback = null){ return (new Route($URLPattern,$callback))->via('post'); } public static function any($URLPattern, $callback = null){ return (new Route($URLPattern,$callback))->via('*'); } public function & with($callback){ $this->callback = $callback; return $this; } public function & before($callback){ $this->befores[] = $callback; return $this; } public function & after($callback){ $this->afters[] = $callback; return $this; } public function & via(...$methods){ $this->methods = []; foreach ($methods as $method){ $this->methods[strtolower($method)] = true; } return $this; } public function & rules(array $rules){ foreach ((array)$rules as $varname => $rule){ $this->rules[$varname] = $rule; } $this->pattern = $this->compilePatternAsRegex( $this->URLPattern, $this->rules ); $this->matcher_pattern = $this->compilePatternAsRegex( $this->URLPattern, $this->rules, false ); return $this; } public static function & map($URLPattern, $callbacks = []){ $route = new static($URLPattern); $route->callback = []; foreach ($callbacks as $method => $callback) { $method = strtolower($method); if (Request::method() !== $method) continue; $route->callback[$method] = $callback; $route->methods[$method] = 1; } return $route; } public function & tag($name){ if ($this->tag = $name) static::$tags[$name] =& $this; return $this; } public function getURL($params = []){ $params = (array)$params; return new URL(rtrim(preg_replace('(/+)','/',preg_replace_callback('(:(\w+))',function($m) use ($params){ return isset($params[$m[1]]) ? $params[$m[1]].'/' : ''; },strtr($this->URLPattern,['('=>'',')'=>'']))),'/')?:'/'); } public static function tagged($name){ return isset(static::$tags[$name]) ? static::$tags[$name] : false; } public static function URL($name, $params = []){ return ($r = static::tagged($name)) ? $r-> getURL($params) : new URL(); } protected static function compilePatternAsRegex($pattern, $rules=[], $extract_params=true){ return '#^'.preg_replace_callback('#:([a-zA-Z]\w*)#',$extract_params ? function($g) use (&$rules){ return '(?<' . $g[1] . '>' . (isset($rules[$g[1]])?$rules[$g[1]]:'[^/]+') .')'; } : function($g) use (&$rules){ return isset($rules[$g[1]]) ? $rules[$g[1]] : '[^/]+'; }, str_replace(['.',')','*'],['\.',')?','.+'],$pattern)).'$#'; } protected static function extractVariablesFromURL($pattern, $URL=null, $cut=false){ $URL = $URL ?: Request::URI(); $pattern = $cut ? str_replace('$#','',$pattern).'#' : $pattern; $args = []; if ( !preg_match(pattern: $pattern, subject: '/'.trim($URL,'/'), matches: $args) ) return false; foreach ($args as $key => $value) { if (false === is_string($key)) unset($args[$key]); } return $args; } public function extractArgs($URL){ $args = []; if ( $this->dynamic ) { preg_match($this->pattern, '/'.trim($URL,'/'), $args); foreach ($args as $key => $value) { if (false === is_string($key)) unset($args[$key]); } } return $args; } protected static function isDynamic($pattern){ return strlen($pattern) != strcspn($pattern,':(?[*+'); } public static function add($route){ if (is_a($route, 'Route')){ static::$compiled = false; static::$compiled_tree = null; static::$compiled_dispatcher = null; if ($route->tag) static::$tags[$route->tag] =& $route; if (Options::get('core.route.auto_optimize', true)){ $base =& static::$optimized_tree; foreach (explode('/',trim(preg_replace('#^(.+?)\(?:.+$#','$1',$route->URLPattern),'/')) as $segment) { $segment = trim($segment,'('); if (!isset($base[$segment])) $base[$segment] = []; $base =& $base[$segment]; } $base[] =& $route; } } if ( isset(static::$group[0]) ) static::$group[0]->add($route); return static::$routes[implode('', static::$prefix)][] = $route; } public static function group($prefix, $callback){ $loop_mode = Options::get('core.route.loop_mode', false); if ($loop_mode) { static::$prefix[] = $prefix; if (empty(static::$group)) static::$group = []; array_unshift(static::$group, $group = new RouteGroup()); call_user_func($callback); array_shift(static::$group); array_pop(static::$prefix); if (empty(static::$prefix)) static::$prefix = ['']; return $group; } $pre_prefix = rtrim(implode('',static::$prefix),'/'); $URI = Request::URI(); $args = []; $group = false; switch (true) { case static::isDynamic($prefix) : $args = static::extractVariablesFromURL($prx=static::compilePatternAsRegex("$pre_prefix$prefix"), null, true); if ( $args !== false ) { $partial = preg_match_all(str_replace('$#', '#', $prx), $URI, $partial) ? $partial[0][0] : ''; $prefix = $partial ? preg_replace('#^'.implode('',static::$prefix).'#', '', $partial) : $prefix; } case ( 0 === strpos("$URI/", "$pre_prefix$prefix/") ) || ( ! Options::get('core.route.pruning', true) ) : static::$prefix[] = $prefix; if (empty(static::$group)) static::$group = []; array_unshift(static::$group, $group = new RouteGroup()); call_user_func_array($callback, $args ?: []); array_shift(static::$group); array_pop(static::$prefix); if (empty(static::$prefix)) static::$prefix = ['']; break; } return $group ?: new RouteGroup(); } public static function exitWithError($code, $message="Application Error"){ Response::error($code,$message); Response::send(); exit; } public static function dispatch($URL=null, $method=null, $return_route=false){ if (!$URL) $URL = Request::URI(); if (!$method) $method = Request::method(); $method = strtolower($method); $debug = Options::get('core.route.debug', false); if ($debug) static::$stats['dispatch']++; Event::trigger('core.log', 'route.dispatch', ['url' => $URL, 'method' => $method]); $__deferred_send = new Deferred(function(){ if (Options::get('core.response.autosend',true)){ Response::send(); } }); $loop_mode = Options::get('core.route.loop_mode', false); if ($loop_mode) { $dispatcher_mode = Options::get('core.route.loop_dispatcher', 'fast'); if ($dispatcher_mode === 'tree') { return static::dispatchCompiledTree($URL, $method, $return_route, $debug); } if (!static::$compiled || empty(static::$compiled_dispatcher)) static::compile(); $dispatcher = static::$compiled_dispatcher; $path = rtrim($URL, '/') ?: '/'; if ($debug) { static::$stats['static_checks']++; } $static_effective = $dispatcher['static_effective'][$method] ?? ($dispatcher['static_effective']['*'] ?? ($dispatcher['static']['*'] ?? [])); $route = $static_effective[$path] ?? null; if ($route) { if ($return_route){ return $route; } else { $route->run($route->extractArgs($URL),$method); if ($debug) { static::$stats['matched']++; static::$stats['static_hit']++; } return true; } } $method_dispatchers = $dispatcher['dynamic'][$method] ?? []; $wildcard_dispatchers = $dispatcher['dynamic']['*'] ?? []; $path_segments = null; $dispatch_lists = [$method_dispatchers, $wildcard_dispatchers]; foreach ($dispatch_lists as $dispatchers) foreach ($dispatchers as $entry) { $prefix = $entry['prefix']; if ($prefix !== '' && $path !== $prefix && strpos($path, $prefix . '/') !== 0) { continue; } $hint = $entry['hint'] ?? ''; if ($hint !== '') { if ($path_segments === null) { $path_segments = array_values(array_filter(explode('/', trim($path,'/')), static function($segment){ return $segment !== ''; })); } $hint_pos = $entry['hint_pos']; if (!isset($path_segments[$hint_pos]) || $path_segments[$hint_pos] !== $hint) { continue; } } if ($debug) { static::$stats['dynamic_checks']++; static::$stats['regex_checks']++; } if (!preg_match($entry['regex'], $path, $matches)) { continue; } foreach ($entry['group_indexes'] as $group_index) { if (!array_key_exists($group_index, $matches) || $matches[$group_index] === '') { continue; } $meta = $entry['meta'][$group_index]; $route = $meta['route']; if ($return_route){ return $route; } else { $args = []; foreach ($meta['param_index'] as $index => $param) { if (isset($matches[$index])) $args[$param] = $matches[$index]; } $route->run($args, $method); if ($debug) { static::$stats['matched']++; static::$stats['dynamic_hit']++; } return true; } } } } else if (empty(static::$optimized_tree)) { foreach ((array)static::$routes as $group => $routes){ foreach ($routes as $route) { if ($debug) static::$stats['static_checks']++; if (is_a($route, 'Route') && $route->match($URL,$method)){ if ($return_route){ return $route; } else { $route->run($route->extractArgs($URL),$method); if ($debug) static::$stats['matched']++; return true; } } } } } else { $routes =& static::$optimized_tree; foreach (explode('/',trim($URL,'/')) as $segment) { if (is_array($routes) && isset($routes[$segment])) $routes =& $routes[$segment]; else if (is_array($routes) && isset($routes[''])) $routes =& $routes['']; else break; } if (is_array($routes) && isset($routes[0]) && !is_array($routes[0])) foreach ((array)$routes as $route) { if ($debug) static::$stats['static_checks']++; if (is_a($route, __CLASS__) && $route->match($URL, $method)){ if ($return_route){ return $route; } else { $route->run($route->extractArgs($URL),$method); if ($debug) static::$stats['matched']++; return true; } } } } Response::status(404, '404 Resource not found.'); foreach (array_filter(array_merge( (static::trigger(404)?:[]), (Event::trigger(404)?:[]) )) as $res){ Response::add($res); } if ($debug) static::$stats['unmatched']++; return false; } protected static function dispatchCompiledTree($URL, $method, $return_route, $debug){ if (!static::$compiled || empty(static::$compiled_tree)) static::compile(); $node = static::$compiled_tree; $depth = 0; foreach (explode('/',trim($URL,'/')) as $segment) { if (isset($node['static'][$segment])) { $node = $node['static'][$segment]; $depth++; } else { break; } } if ($debug) { static::$stats['depth_total'] += $depth; static::$stats['depth_max'] = max(static::$stats['depth_max'], $depth); } foreach ((array)$node['routes'] as $route) { if ($debug) static::$stats['static_checks']++; if (is_a($route, __CLASS__) && $route->match($URL, $method)){ if ($return_route){ return $route; } else { $route->run($route->extractArgs($URL),$method); if ($debug) static::$stats['matched']++; return true; } } } foreach ((array)$node['dynamic_routes'] as $entry) { if ($debug) static::$stats['dynamic_checks']++; $route = $entry['route']; if (is_a($route, __CLASS__) && $route->match($URL, $method)){ if ($return_route){ return $route; } else { $route->run($route->extractArgs($URL),$method); if ($debug) static::$stats['matched']++; return true; } } } return false; } public function push($links, $type = 'text'){ Response::push($links, $type); return $this; } } class RouteGroup { protected $routes; public function __construct(){ $this->routes = new SplObjectStorage; return Route::add($this); } public function has($r){ return $this->routes->offsetExists($r); } public function add($r){ $this->routes[$r] = true; return $this; } public function remove($r){ if ($this->routes->offsetExists($r)) $this->routes->offsetUnset($r); return $this; } public function before($callbacks){ foreach ($this->routes as $route){ $route->before($callbacks); } return $this; } public function after($callbacks){ foreach ($this->routes as $route){ $route->after($callbacks); } return $this; } public function push($links, $type = 'text'){ Response::push($links, $type); return $this; } }class SQL { use Module, Events; protected static $connections = [], $current = 'default'; public static function register($name, $dsn, $username=null, $password=null, $options=[]){ return self::$connections[$name] = new SQLConnection($dsn, $username, $password, $options); } public static function connect($dsn, $username=null, $password=null, $options=[]){ return self::register('default', $dsn, $username, $password, $options); } public static function defaultTo($name){ if (isset(self::$connections[$name])){ self::$current = $name; return true; } else return false; } public static function close($name=null){ if ($name === null) { foreach (self::$connections as $conn) $conn->close(); return true; } else if (isset(self::$connections[$name])){ self::$connections[$name]->close(); return true; } else return false; } public static function hasConnection($name='default'){ return isset(self::$connections[$name]); } public static function using($name){ if (empty(self::$connections[$name])) throw new \Exception("[SQL] Unknown connection named '$name'."); return self::$connections[$name]; } public static function __callStatic($method, $args){ if (empty(self::$connections[self::$current])) throw new \Exception("[SQL] No default connection defined."); return call_user_func_array([self::$connections[self::$current],$method],$args); } } if (!SQL::hasConnection('default')) { SQL::connect('sqlite::memory:'); } class SQLConnection { protected $connection = [], $queries = [], $last_exec_success = true, $is_mysql = false; public function __construct($dsn, $username=null, $password=null, $options=[]){ $this->is_mysql = strpos($dsn,'mysql:') === 0; $base_options = [ PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC, PDO::ATTR_EMULATE_PREPARES => false, ]; if ($this->is_mysql && defined('PDO::MYSQL_ATTR_MULTI_STATEMENTS')) { $base_options[PDO::MYSQL_ATTR_MULTI_STATEMENTS] = true; } $this->connection = [ 'dsn' => $dsn, 'pdo' => null, 'username' => $username, 'password' => $password, 'options' => array_merge($base_options, $options), ]; } public function close(){ $this->connection['pdo'] = null; } public function connection(){ if(empty($this->connection['pdo'])) { try { $this->connection['pdo'] = new PDO( $this->connection['dsn'], $this->connection['username'], $this->connection['password'], $this->connection['options'] ); SQL::trigger('connect',$this); Event::trigger('core.sql.connect',$this); } catch(Exception $e) { $this->connection['pdo'] = null; } } return $this->connection['pdo']; } public function prepare($query, $pdo_params=[]){ if(!$this->connection()) return false; return isset($this->queries[$query]) ? $this->queries[$query] : ($this->queries[$query] = $this->connection()->prepare($query, $pdo_params)); } public function exec($query, $params=[], $pdo_params=[]){ if(!$this->connection()) return false; if (false==is_array($params)) $params = (array)$params; $query = Filter::with('core.sql.query',$query); if($statement = $this->prepare($query, $pdo_params)){ SQL::trigger('query',$query,$params,(bool)$statement); Event::trigger('core.sql.query',$query,$params,(bool)$statement); foreach ($params as $key => $val) { $type = PDO::PARAM_STR; if (is_bool($val)) { $type = PDO::PARAM_BOOL; } elseif (is_null($val)) { $type = PDO::PARAM_NULL; } elseif (is_int($val)) { $type = PDO::PARAM_INT; } $statement->bindValue(is_numeric($key)?$key+1:':'.$key, $val, $type); } } else { $error = $this->connection['pdo']->errorInfo(); SQL::trigger('error',$error[2], $query, $params, $error); Event::trigger('core.sql.error',$error[2], $query, $params, $error); Event::trigger('core.log', 'sql.error', ['message' => $error[2], 'query' => $query, 'params' => $params]); return false; } $this->last_exec_success = $statement && $statement->execute(); return $statement; } public function value($query, $params=[], $column=0){ if(!$this->connection()) return false; $res = $this->exec($query,$params); return $res ? $res->fetchColumn($column) : null; } public function column($query, $params=[], $column=0){ if(!$this->connection()) return false; $results = []; $res = $this->exec($query,$params); if (is_string($column)) while ($x = $res->fetch(PDO::FETCH_OBJ)) $results[] = $x->$column; else while ($x = $res->fetchColumn($column)) $results[] = $x; return $results; } public function reduce($query, $params=[], $looper = null, $initial = null){ if(!$this->connection()) return false; if (is_callable($params)) { $initial = $looper; $looper = $params; $params = []; } if(( $res = $this->exec($query,$params, $this->bufferedQueryParams()) ) && is_callable($looper) ){ while ($row = $res->fetchObject()) { $initial = $looper($initial, $row); } return $initial; } else return false; } public function each($query, $params=[], ?callable $looper = null){ if(!$this->connection()) return false; if ($looper===null && is_callable($params)) {$looper = $params; $params = [];} if( $res = $this->exec($query,$params, $this->bufferedQueryParams()) ){ if(is_callable($looper)) { while ($row = $res->fetchObject()) $looper($row); return true; } else return $res->fetchAll(PDO::FETCH_CLASS); } else return false; } public function single($query, $params=[], ?callable $handler = null){ if(!$this->connection()) return false; if ($handler===null && is_callable($params)) {$handler = $params; $params = [];} if( $res = $this->exec($query,$params, $this->bufferedQueryParams()) ){ if (is_callable($handler)) return $handler($res->fetchObject()); else return $res->fetchObject(); } } private function bufferedQueryParams(): array { return ($this->is_mysql && defined('PDO::MYSQL_ATTR_USE_BUFFERED_QUERY')) ? [PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => true] : []; } public function run($script){ if(!$this->connection()) return false; $sql_path = Options::get('database.sql.path',APP_DIR.'/sql'); $sql_sep = Options::get('database.sql.separator',';'); if (is_file($f = "$sql_path/$script.sql")){ $result = true; foreach(explode($sql_sep,file_get_contents($f)) as $statement) { $result = $this->exec($statement); } return $result; } else return false; } public function all($query, $params=[], ?callable $looper = null){ if(!$this->connection()) return false; return $this->each($query,$params,$looper); } public function delete($table, $pks=null, $pk='id', $inclusive=true){ if(!$this->connection()) return false; if (null===$pks) { return $this->exec("DELETE FROM `$table`"); } else { return $this->exec("DELETE FROM `$table` WHERE `$pk` ".($inclusive ? "" : "NOT " )."IN (" . implode( ',', array_fill_keys( (array)$pks, '?' ) ) . ")",(array)$pks); } } public function insert($table, $data, $pk='id'){ if(!$this->connection()) return false; if (false==is_array($data)) $data = (array)$data; $k = array_keys($data); asort($k); $pk_a = $k; array_walk($pk_a,function(&$e){ $e = ':'.$e;}); $q = "INSERT INTO `$table` (`".implode('`,`',$k)."`) VALUES (".implode(',',$pk_a).")"; $this->exec($q,$data); return $this->last_exec_success ? $this->connection()->lastInsertId($pk) : false; } public function updateWhere($table, $data, $where, $pk='id'){ if(!$this->connection()) return false; if (false==is_array($data)) $data = (array)$data; if (empty($data)) return false; $k = array_keys($data); asort($k); array_walk($k,function(&$e) use ($pk) { $e = ($e==$pk) ? null : "`$e`=:$e"; }); $q = "UPDATE `$table` SET ".implode(', ',array_filter($k))." WHERE $where"; $this->exec($q, $data); $data = (object)$data; return $this->last_exec_success ? $data->$pk : false; } public function update($table, $data, $pk='id', $extra_where=''){ return $this->updateWhere($table, $data, "`$pk`=:$pk $extra_where", $pk); } public function insertOrUpdate($table, $data=[], $pk='id', $extra_where=''){ if(!$this->connection()) return false; if (false==is_array($data)) $data = (array)$data; if (empty($data[$pk])) return $this->insert($table, $data); if( (string) $this->value("SELECT `$pk` FROM `$table` WHERE `$pk`=? LIMIT 1", [$data[$pk]]) === (string) $data[$pk] ){ return $this->update($table, $data, $pk, $extra_where); } else { return $this->insert($table, $data, $pk); } } }class Schedule { use Module; protected static $jobs = []; public static function register($name, $cron, $type, $payload = null) { static::$jobs[$name] = [ 'cron' => $cron, 'type' => $type, 'payload' => $payload, ]; } public static function unregister($name) { unset(static::$jobs[$name]); } public static function due($time = null) { $time = $time ?? time(); $due = []; foreach (static::$jobs as $name => $job) { if (static::matches($job['cron'], $time)) { $due[] = [ 'name' => $name, 'type' => $job['type'], 'payload' => $job['payload'], ]; } } return $due; } public static function run($time = null) { $queued = []; foreach (static::due($time) as $job) { Job::queue($job['type'], $job['payload']); $queued[] = $job['name']; } return $queued; } public static function all() { return static::$jobs; } public static function flush() { static::$jobs = []; } public static function matches($cron, $time) { $parts = preg_split('/\s+/', trim($cron)); if (count($parts) !== 5) return false; $checks = [ (int) date('i', $time), (int) date('G', $time), (int) date('j', $time), (int) date('n', $time), (int) date('w', $time), ]; for ($i = 0; $i < 5; $i++) { if (!static::fieldMatches($parts[$i], $checks[$i])) { return false; } } return true; } protected static function fieldMatches($field, $value) { if ($field === '*') return true; foreach (explode(',', $field) as $part) { if (strpos($part, '/') !== false) { list($range, $step) = explode('/', $part, 2); $step = (int) $step; if ($step < 1) $step = 1; if ($range === '*') { if ($value % $step === 0) return true; } elseif (strpos($range, '-') !== false) { list($min, $max) = explode('-', $range, 2); $min = (int) $min; $max = (int) $max; if ($value >= $min && $value <= $max && ($value - $min) % $step === 0) return true; } continue; } if (strpos($part, '-') !== false) { list($min, $max) = explode('-', $part, 2); if ($value >= (int) $min && $value <= (int) $max) return true; continue; } if ((int) $part === $value) return true; } return false; } }class Schema { use Module; protected static $cache = []; public static function describe($modelOrTable) { $table = static::resolveTable($modelOrTable); if (isset(static::$cache[$table])) return static::$cache[$table]; $driver = static::detectDriver(); if ($driver === 'sqlite') { $columns = static::describeSQLite($table); } else { $columns = static::describeMySQL($table); } return static::$cache[$table] = $columns; } public static function tables() { $driver = static::detectDriver(); if ($driver === 'sqlite') { return SQL::column("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name"); } return SQL::column("SHOW TABLES"); } public static function columns($modelOrTable) { return array_column(static::describe($modelOrTable), 'name'); } public static function hasTable($table) { return in_array($table, static::tables(), true); } public static function flush() { static::$cache = []; } protected static function resolveTable($modelOrTable) { if (class_exists($modelOrTable) && is_subclass_of($modelOrTable, 'Model')) { return $modelOrTable::persistenceOptions('table'); } return $modelOrTable; } protected static function detectDriver() { try { $driver = SQL::value("SELECT 'sqlite' WHERE 1=0"); $pdo = static::getPDO(); if ($pdo) return $pdo->getAttribute(\PDO::ATTR_DRIVER_NAME); } catch (\Exception $e) {} return 'sqlite'; } protected static function getPDO() { if (SQL::hasConnection('default')) { $conn = SQL::using('default'); if (method_exists($conn, 'connection')) { return $conn->connection(); } } return null; } protected static function describeSQLite($table) { $columns = []; $rows = SQL::each("PRAGMA table_info(`$table`)"); if ($rows) { foreach ($rows as $row) { $row = (object) $row; $columns[] = [ 'name' => $row->name, 'type' => strtolower($row->type ?: 'text'), 'nullable' => !$row->notnull, 'default' => $row->dflt_value, 'key' => $row->pk ? 'PRI' : '', ]; } } return $columns; } protected static function describeMySQL($table) { $columns = []; $rows = SQL::each("SHOW COLUMNS FROM `$table`"); if ($rows) { foreach ($rows as $row) { $row = (object) $row; $columns[] = [ 'name' => $row->Field, 'type' => strtolower($row->Type), 'nullable' => $row->Null === 'YES', 'default' => $row->Default, 'key' => $row->Key === 'PRI' ? 'PRI' : ($row->Key ?: ''), ]; } } return $columns; } }class SecurityHeaders { use Module; public static function apply(array $overrides = []){ if (!Options::get('core.security.headers.enabled', true)) return; $defaults = Options::get('core.security.headers.defaults', [ 'X-Frame-Options' => 'SAMEORIGIN', 'X-Content-Type-Options' => 'nosniff', 'Referrer-Policy' => 'strict-origin-when-cross-origin', 'Permissions-Policy' => 'interest-cohort=()', 'Cross-Origin-Resource-Policy' => 'same-site', ]); if (!empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off') { if (!isset($defaults['Strict-Transport-Security'])) { $defaults['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'; } } $headers = array_merge($defaults, $overrides); $existing = Response::headers(); foreach ($headers as $name => $value) { if (isset($existing[$name]) && !array_key_exists($name, $overrides)) continue; Response::header($name, $value); } } }class Service { use Module; private static $services = []; public static function register($serviceName, $serviceFactory){ static::$services[$serviceName] = function(...$args) use ($serviceName, $serviceFactory) { return static::$services[$serviceName] = $serviceFactory(...$args); }; } public static function registerFactory($serviceName, $serviceFactory){ static::$services[$serviceName] = function(...$args) use ($serviceName, $serviceFactory) { return $serviceFactory(...$args); }; } public static function __callStatic($serviceName, $serviceParameters){ $servs = static::$services; return empty($servs[$serviceName]) ? null : (is_callable($servs[$serviceName]) ? $servs[$serviceName](...$serviceParameters) : $servs[$serviceName] ); } }class Session { use Module, Events; static public function start($name=null){ if (isset($_SESSION)) return; $ln = static::name($name); if (PHP_VERSION_ID < 80500) { if (ini_get('session.sid_length') !== false) { ini_set('session.sid_length', '48'); } if (ini_get('session.sid_bits_per_character') !== false) { ini_set('session.sid_bits_per_character', '6'); } } if (ini_get('session.use_strict_mode') !== false) { ini_set('session.use_strict_mode', '1'); } if (ini_get('session.use_only_cookies') !== false) { ini_set('session.use_only_cookies', '1'); } session_cache_limiter('must-revalidate'); if (session_status() == PHP_SESSION_NONE) { @session_start(); } static::trigger("start", $name?:$ln); } static public function cookieParams($args = []) { if (empty($args)) return session_get_cookie_params(); $args = array_merge(session_get_cookie_params(), $args); if (array_key_exists('samesite', $args)) { session_set_cookie_params($args); } else { session_set_cookie_params( lifetime: $args["lifetime"], path: $args["path"], domain: $args["domain"], secure: $args["secure"], httponly: $args["httponly"] ); } return $args; } static public function name($name=null){ return $name ? session_name($name) : session_name(); } static public function get($key,$default=null){ if (($active = static::active()) && isset($_SESSION[$key])) { return $_SESSION[$key]; } else if ($active) { return $_SESSION[$key] = (is_callable($default)?call_user_func($default):$default); } else { return (is_callable($default)?call_user_func($default):$default); } } static public function set($key,$value=null){ static::start(); if($value==null && is_array($key)){ foreach($key as $k=>$v) $_SESSION[$k]=$v; } else { $_SESSION[$key] = $value; } } static public function delete($key){ static::start(); unset($_SESSION[$key]); } static public function clear(){ static::start(); session_unset(); session_destroy(); static::trigger("end"); } static public function active(){ return session_status() == PHP_SESSION_ACTIVE; } static public function exists($key){ static::start(); return isset($_SESSION[$key]); } static public function readOnly(){ return new SessionReadOnly; } } class SessionReadOnly { public function get($key){ return Session::get($key); } public function __get($key){ return Session::get($key); } public function name(){ return Session::name(); } public function exists($key){ return Session::exists($key); } public function __isset($key){ return Session::exists($key); } }class Shell { use Module; protected static $aliases = []; protected $command; protected static function _compileCommand($command,array $params){ $s = $w = []; foreach ($params as $p) { if ($p instanceof static) { $s[] = '$('.$p->getShellCommand().')'; } else if (is_array($p)) foreach ($p as $key => $value) { if(is_numeric($key)){ $w[] = '--'.$value; } else { if(is_bool($value)){ if($value) $w[] = '--'.$key; } else { $w[] = '--'.$key.'='.escapeshellarg($value); } } } else { $s[] = $p; } } return trim( '/usr/bin/env '.$command.' '.implode(' ',array_merge($w,$s)) ); } public function getShellCommand(){ return $this->command; } public static function __callStatic($command,$params){ $aliases = static::$aliases; if (isset($aliases[$command])){ if(!$results = $aliases[$command](...$params)) throw new Exception('Shell aliases must return a Shell class or a command string.'); return $results instanceof static? $results : new static($results); } else { return new static($command,$params); } } public function __construct($command,$params=null){ $this->command = $params?static::_compileCommand($command,$params):$command; } public function __toString(){ $output = []; exec($this->command,$output,$error_code); return empty($output)?'':implode(PHP_EOL,$output); } public static function pipe(){ $cmd = []; foreach (func_get_args() as $item) { $cmd[] = ($item instanceof static)?$item->getShellCommand():$item; } return new static(implode(' | ',$cmd)); } public static function sequence(...$items){ $cmd = []; foreach ($items as $item) { $cmd[] = ($item instanceof static)?$item->getShellCommand():$item; } return new static(implode(' && ',$cmd)); } public static function execCommand($command,$params = null){ return new static($command,$params); } public static function alias($command,callable $callback){ static::$aliases[$command] = $callback; } public static function escape($arg){ return escapeshellarg($arg); } public function run(){ return $this->__toString(); } }class Structure extends ArrayObject { public function __construct($input=[], $deep=true){ $data = is_string($input) ? json_decode($input,true) : (array)$input; if (is_array($data)){ if ($deep) { foreach ($data as $key => &$value) { if (is_array($value) || is_a($value,'stdClass')){ $value = new self($value); } } } parent::__construct($data, static::ARRAY_AS_PROPS); } else { throw new InvalidArgumentException( 'Argument must be a string containing valid JSON, an array or an stdClass.' ); } } public function offsetSet(mixed $key, mixed $value): void{ if ( is_array($value) ) parent::offsetSet($key, new static($value)); else parent::offsetSet($key, $value); } public function offsetGet(mixed $key): mixed{ $raw = parent::offsetGet($key); return is_callable($raw) ? call_user_func($raw) : $raw; } public function __call($method, $args){ $raw = parent::offsetGet($method); if (is_callable($raw)) { if ($raw instanceof \Closure) $raw->bindTo($this); return call_user_func_array($raw, $args); } } public function __toString(){ return json_encode($this,JSON_NUMERIC_CHECK); } public static function fetch($path, $root) { $_ = (array)$root; if (strpos($path,'.') === false) { return isset($_[$path]) ? $_[$path] : null; } else { list($frag,$rest) = explode('.', $path, 2); if ($rest) { return isset($_[$frag]) ? self::fetch($rest, $_[$frag]) : null; } elseif ($frag) { return (array)$_[$frag]; } else { return null; } } } public static function create($class, $args = null){ return is_array($args) ? (new ReflectionClass($class))->newInstanceArgs($args) : new $class; } public static function canBeString($var) { return $var === null || is_scalar($var) || is_callable([$var, '__toString']); } }class Text { use Module; public static function render($t,$v=null){ if (Options::get('core.text.replace_empties', true)) { $replacer = function($c) use ($v){ return Structure::fetch(trim($c[1]), $v); }; } else { $replacer = function($c) use ($v){ return Structure::fetch(trim($c[1]), $v) ?: $c[0]; }; } return preg_replace_callback("(\{\{([^}]+)\}\})S",$replacer,$t); } public static function slugify($text){ return preg_replace( ['(\s+)','([^a-z0-9-])i','(-+)'],['-','','-'], strtolower(self::removeAccents($text))); } public static function removeAccents($text){ static $map = null; if ($map === null) { $from = preg_split('//u', '', -1, PREG_SPLIT_NO_EMPTY); $to = str_split('aaaaaceeeeiiiinooooouuuuyyAAAAACEEEEIIIINOOOOOUUUUY'); $map = array_combine($from, $to); } return strtr($text, $map); } public static function cut($text, $start_tag, $end_tag=null){ $_s = strlen($start_tag) + strpos($text, $start_tag); return $end_tag ? substr($text, $_s, strpos($text,$end_tag,$_s)-$_s) : substr($text, $_s); } }class Token { public static function encode($payload, $secret, $algo = 'HS256') { $encoded_payload = implode('.', [rtrim(strtr(base64_encode(json_encode([ 'typ' => 'JWT', 'alg' => $algo, ])), '+/', '-_'),'='), rtrim(strtr(base64_encode(json_encode($payload)), '+/', '-_'),'='), ]); return $encoded_payload . '.' . static::sign($encoded_payload, $secret, $algo); } public static function decode($jwt, $secret = null, $verify = true){ if (substr_count($jwt,'.') != 2) throw new \Exception('Token not valid'); list($encoded_header, $encoded_payload, $client_sig) = explode('.', $jwt); if (null === ($payload = json_decode(base64_decode(strtr($encoded_payload, '-_', '+/'))))) throw new \Exception('Invalid encoding'); if ($verify) { if (null === ($header = json_decode(base64_decode(strtr($encoded_header, '-_', '+/'))))) throw new \Exception('Invalid encoding'); if (empty($header->alg)) throw new \Exception('Invalid encoding'); if ($secret === null || $secret === '') throw new \Exception('Token verification failed'); if ($client_sig != static::sign("$encoded_header.$encoded_payload", $secret, $header->alg)) throw new \Exception('Token verification failed'); } return $payload; } protected static function sign($payload, $secret, $algo = 'HS256') { $algos = [ 'HS512' => 'sha512', 'HS384' => 'sha384', 'HS256' => 'sha256', ]; if (empty($algos[$algo])) throw new \Exception('Signing algorithm not supported'); return rtrim(strtr(base64_encode(hash_hmac($algos[$algo], $payload, $secret, true)), '+/', '-_'),'='); } }class URL { private $_origin = '', $_parsed = false, $scheme = false, $user = false, $pass = false, $host = false, $port = false, $path = false, $query = [], $fragment = false; public function __construct($url=''){ if (empty($url) || !is_string($url)) return; $this->_origin = $url; } private function parse(){ $url = $this->_origin; $tmp_url = (strpos($url, '://') === false) ? "..N..://$url" : $url; if (mb_detect_encoding($tmp_url, 'UTF-8', true) || ($parsed = parse_url($tmp_url)) === false) { preg_match( pattern: '(^((?P<scheme>[^:/?#]+):(//))?((\\3|//)?(?:(?P<user>[^:]+):(?P<pass>[^@]+)@)?(?P<host>[^/?:#]*))(:(?P<port>\\d+))?(?P<path>[^?#]*)(\\?(?P<query>[^#]*))?(#(?P<fragment>.*))?)u', subject: $tmp_url, matches: $parsed ); } foreach($parsed as $k => $v) if(isset($this->$k)) $this->$k = $v; if ($this->scheme == '..N..') $this->scheme = null; if (!empty($this->query)) { parse_str(string: $this->query, result: $this->query); } $this->_parsed = true; } public function & __get($name){ $this->_parsed || $this->parse(); if (isset($this->$name)) return $this->$name; else throw new Exception('Trying to read an unknown URL property'); } public function __set($name, $value){ $this->_parsed || $this->parse(); return $this->$name = $value; } public function __toString(){ if ($this->_parsed) { $d = []; if ($this->scheme) $d[] = "{$this->scheme}://"; if ($this->user) $d[] = "{$this->user}" . (empty($this->pass)?'':":{$this->pass}") . "@"; if ($this->host) $d[] = "{$this->host}"; if ($this->port) $d[] = ":{$this->port}"; if ($this->path) $d[] = "/" . ltrim($this->path,"/"); if (!empty($this->query)) $d[] = "?" . http_build_query($this->query); if ($this->fragment) $d[] = "#{$this->fragment}"; return implode('', $d); } else { return $this->_origin; } } }class View { use Module; protected static $handler = null; protected $options = [ 'template' => '', 'data' => [], ]; public function __construct($template){ foreach ((array)$template as $templ){ if (static::$handler->exists($templ)) return $this->options['template'] = $templ; } throw new Exception("[Core.View] Template not found."); } public static function using(View\Adapter $handler){ static::$handler = $handler; } public static function from($template,$data=null){ $view = new self($template); return $data ? $view->with($data) : $view; } public function with($data){ if ($data){ $tmp = array_merge($data, (isset($this->options['data'])?$this->options['data']:[])); $this->options['data'] = $tmp; } return $this; } public function __toString(){ return Filter::with('core.view',static::$handler->render($this->options['template'],$this->options['data'])); } public static function & handler(){ return static::$handler; } public static function exists($templatePath){ return static::$handler->exists($templatePath); } public function __call($n,$p){ return call_user_func_array([static::$handler,$n],$p); } public static function __callStatic($n,$p){ return forward_static_call_array([static::$handler,$n],$p); } }class WebSocket { use Module, Events; protected static $driver = null; public static function using($driver) { foreach ((array) $driver as $key => $value) { if (is_numeric($key)) { $drv = $value; $conf = []; } else { $drv = $key; $conf = $value; } $class = 'WebSocket\\' . ucfirst(strtolower($drv)); if (class_exists($class) && $class::valid()) { static::$driver = new $class($conf); return true; } } return false; } public static function send($channel, $data) { if (!static::$driver) return false; $result = static::$driver->send($channel, $data); static::trigger('send', $channel, $data, $result); return $result; } public static function broadcast($channel, $data) { if (!static::$driver) return false; $result = static::$driver->broadcast($channel, $data); static::trigger('broadcast', $channel, $data, $result); return $result; } public static function subscribe($channel, callable $callback) { static::on("channel:{$channel}", $callback); } public static function ready() { return static::$driver !== null; } }class Work { use Module; protected static $pool = null; protected static $workers; protected static $lastID = 0; public static function add($id, $job=null){ self::$pool or ( self::$pool = new \SplQueue() ); if(is_callable($id) && $job===null){ $job = $id; $id = ++self::$lastID; } $task = new TaskCoroutine($id, $job instanceof \Generator ? $job : $job()); self::$workers[$id] = $task; self::$pool->enqueue($task); return $task; } public static function send($id,$passValue) { isset(self::$workers[$id]) && self::$workers[$id]->pass($passValue); } public static function run(){ self::$pool or ( self::$pool = new \SplQueue() ); while (!self::$pool->isEmpty()) { $task = self::$pool->dequeue(); $task->run(); if ($task->complete()) { unset(self::$workers[$task->id()]); } else { self::$pool->enqueue($task); } } } public static function after(callable $callback){ static::$inited_shutdown || static::install_shutdown(); Event::on('core.shutdown', $callback); } protected static function install_shutdown(){ if (static::$inited_shutdown) return; set_time_limit(0); if(function_exists('register_postsend_function')){ register_postsend_function(function(){ Event::trigger('core.shutdown'); }); } else if(function_exists('fastcgi_finish_request')) { register_shutdown_function(function(){ fastcgi_finish_request(); Event::trigger('core.shutdown'); }); } else { register_shutdown_function(function(){ Event::trigger('core.shutdown'); }); } static::$inited_shutdown = true; } } class TaskCoroutine { protected $id; protected $coroutine; protected $passValue = null; protected $beforeFirstYield = true; protected static $inited_shutdown = false; public function __construct($id, \Generator $coroutine) { $this->id = $id; $this->coroutine = $coroutine; } public function id() { return $this->id; } public function pass($passValue) { $this->passValue = $passValue; } public function run() { if ($this->beforeFirstYield) { $this->beforeFirstYield = false; return $this->coroutine->current(); } else { $retval = $this->coroutine->send($this->passValue); $this->passValue = null; return $retval; } } public function complete() { return ! $this->coroutine->valid(); } }class ZIP { use Module; public $file, $name, $zip; public static function create($name=''){ return new ZIP($name); } public function __construct($name=''){ $this->name = preg_replace('/\.zip$/','',($name?:tempnam(sys_get_temp_dir(), 'ZExp').'-archive')); $this->file = $this->name . '.zip'; if (!preg_match('~^(?:/|\\\\\\\\|[A-Za-z]:[\\\\/]|\\./|\\.\\./)~', $this->file)) { $this->file = './' . $this->file; } $this->zip = new \ZipArchive; if ( true !== ($e = $this->zip->open($this->file, \ZipArchive::CREATE | \ZipArchive::OVERWRITE ))) { throw new Exception("Error opening temp ZIP file [".($this->file)."] Code $e", 1); } } public function __destruct(){ $this->close(); } public function path(){ return $this->file; } public function write($filename, $data){ $this->zip->addFromString($filename, $data); return $this; } public function close(){ if ($this->zip instanceof \ZipArchive) { @$this->zip->close(); $this->zip = null; } return $this; } public function addDirectory($folder, $root=null) { $folder = rtrim($folder,'/'); if (null === $root) { $root = dirname($folder); $folder = basename($folder); } $this->zip->addEmptyDir($folder); foreach (glob("$root/$folder/*") as $item) { if (is_dir($item)) { $this->addDirectory(str_replace($root,'',$item),$root); } else if (is_file($item)) { $this->zip->addFile($item, str_replace($root,'',$item)); } } return $this; } public function download(){ @$this->zip->close(); header('Content-Type: application/zip'); header('Content-Disposition: attachment;filename="'.$this->name.'"',true); header('Content-Transfer-Encoding: binary'); header('Expires: 0'); header('Cache-Control: must-revalidate, post-check=0, pre-check=0'); header('Pragma: public'); header('Content-Length: '.filesize($this->file)); while(ob_get_level()) ob_end_clean(); readfile($this->file); exit; } }class i18n { use Module; protected static $locale = 'en'; protected static $translations = []; protected static $fallback = 'en'; public static function locale($locale = null) { if ($locale !== null) { static::$locale = $locale; } return static::$locale; } public static function fallback($fallback = null) { if ($fallback !== null) { static::$fallback = $fallback; } return static::$fallback; } public static function t($key, $params = []) { $value = static::resolve($key, static::$locale); if ($value === null && static::$locale !== static::$fallback) { $value = static::resolve($key, static::$fallback); } if ($value === null) return $key; if ($params) { $value = Text::render($value, $params); } return $value; } public static function load($locale, $filepath) { if (!is_file($filepath)) return; $ext = strtolower(pathinfo($filepath, PATHINFO_EXTENSION)); if ($ext === 'json') { $data = json_decode(file_get_contents($filepath), true); } else { ob_start(); $data = include $filepath; ob_end_clean(); } if (is_array($data)) { if (!isset(static::$translations[$locale])) { static::$translations[$locale] = []; } static::$translations[$locale] = array_replace_recursive( static::$translations[$locale], $data ); } } public static function loadArray($locale, array $data) { if (!isset(static::$translations[$locale])) { static::$translations[$locale] = []; } static::$translations[$locale] = array_replace_recursive( static::$translations[$locale], $data ); } public static function has($key, $locale = null) { return static::resolve($key, $locale ?? static::$locale) !== null; } public static function all($locale = null) { $locale = $locale ?? static::$locale; return static::$translations[$locale] ?? []; } public static function flush() { static::$translations = []; } protected static function resolve($key, $locale) { if (!isset(static::$translations[$locale])) return null; $segments = explode('.', $key); $current = static::$translations[$locale]; foreach ($segments as $segment) { if (!is_array($current) || !array_key_exists($segment, $current)) { return null; } $current = $current[$segment]; } return is_string($current) ? $current : null; } }}
namespace CLI\UI {class Facade { private Terminal $terminal; private Style $style; public function __construct(?Terminal $terminal = null) { $this->terminal = $terminal ?? new Terminal(); $this->style = new Style($this->terminal); } public function input(string $prompt, array $opts = []): string { $default = $opts['default'] ?? ''; $placeholder = $opts['placeholder'] ?? ''; $label = $this->decoratePrompt($prompt, $default, $placeholder, $opts); $scriptedValue = $opts['scripted_value'] ?? ($default !== '' ? $default : ($placeholder !== '' ? $placeholder : 'demo')); $line = $this->readLine($label, false, [ 'scripted' => !empty($opts['scripted']), 'scripted_value' => (string)$scriptedValue, ]); $line = trim($line); return $line === '' ? (string)$default : $line; } public function confirm(string $prompt, array $opts = []): bool { $default = $opts['default'] ?? false; $suffix = $default ? '[Y/n]' : '[y/N]'; $label = $this->decoratePrompt("$prompt $suffix", '', '', $opts); $scriptedValue = $opts['scripted_value'] ?? ($default ? 'y' : 'n'); $line = strtolower(trim($this->readLine($label, false, [ 'scripted' => !empty($opts['scripted']), 'scripted_value' => (string)$scriptedValue, ]))); if ($line === '') return (bool)$default; return in_array($line[0], ['y', '1', 't'], true); } public function select(string $prompt, array $items, array $opts = []) { if (!$items) return $opts['default'] ?? null; $list_opts = $opts; if (!empty($opts['card'])) { $list_opts['card_title'] = $prompt; $this->printList('', $items, false, $list_opts); } else { $this->printList($prompt, $items, true, $opts); } $default = $opts['default'] ?? null; $scriptedValue = $opts['scripted_value'] ?? ($opts['scripted_select'] ?? '2'); $line = trim($this->readLine($this->decoratePrompt('Select [1-' . count($items) . ']', '', '', $opts + ['card_prompt' => false]), false, [ 'scripted' => !empty($opts['scripted']), 'scripted_value' => (string)$scriptedValue, ])); if ($line === '' && $default !== null) return $default; $idx = (int)$line; if ($idx < 1 || $idx > count($items)) return $items[0]; return $items[$idx - 1]; } public function multiSelect(string $prompt, array $items, array $opts = []): array { if (!$items) return []; $list_opts = $opts; if (!empty($opts['card'])) { $list_opts['card_title'] = $prompt; $this->printList('', $items, false, $list_opts); } else { $this->printList($prompt, $items, true, $opts); } $scriptedValue = $opts['scripted_value'] ?? ($opts['scripted_select'] ?? '1,3'); $line = trim($this->readLine($this->decoratePrompt('Select (comma separated)', '', '', $opts + ['card_prompt' => false]), false, [ 'scripted' => !empty($opts['scripted']), 'scripted_value' => (string)$scriptedValue, ])); if ($line === '') return (array)($opts['default'] ?? []); $parts = array_filter(array_map('trim', explode(',', $line))); $out = []; foreach ($parts as $part) { $idx = (int)$part; if ($idx >= 1 && $idx <= count($items)) { $out[] = $items[$idx - 1]; } } return $out; } public function filter(string $prompt, array $items, array $opts = []) { if (!$items) return $opts['default'] ?? null; $scriptedValue = $opts['scripted_value'] ?? 'ap'; $queryScripted = $opts['scripted_query'] ?? ($opts['scripted_value'] ?? 'ap'); $query = trim($this->readLine($this->decoratePrompt("$prompt (type to filter)", '', '', $opts + ['card_prompt' => false]), false, [ 'scripted' => !empty($opts['scripted']), 'scripted_value' => (string)$queryScripted, ])); $filtered = $this->filterItems($items, $query, $opts['fuzzy'] ?? true); if (!$filtered) $filtered = $items; $list_opts = $opts; if (!empty($opts['scripted_select'])) { $list_opts['scripted_value'] = (string)$opts['scripted_select']; } if (!empty($opts['card'])) { $list_opts['card_title'] = 'Filtered results'; } return $this->select('Filtered results', $filtered, $list_opts); } public function password(string $prompt, array $opts = []): string { if (!$this->terminal->isTTY()) { return $this->readLine($this->decoratePrompt($prompt, '', '', $opts), false, [ 'scripted' => !empty($opts['scripted']), 'scripted_value' => (string)($opts['scripted_value'] ?? 'secret'), ]); } if (stripos(PHP_OS_FAMILY, 'Windows') !== false) { if (!empty($opts['scripted'])) { return $this->readLine($this->decoratePrompt($prompt, '', '', $opts), true, [ 'scripted' => true, 'scripted_value' => (string)($opts['scripted_value'] ?? 'secret'), ]); } return $this->readPasswordWindows($prompt, $opts); } return $this->readLine($this->decoratePrompt($prompt, '', '', $opts), true, [ 'scripted' => !empty($opts['scripted']), 'scripted_value' => (string)($opts['scripted_value'] ?? 'secret'), ]); } public function file(string $prompt, array $opts = []): string { $root = $opts['root'] ?? getcwd(); $root = $root ?: getcwd(); $current = realpath($root) ?: $root; $scripted = !empty($opts['scripted']); while (true) { if (empty($opts['card'])) { $this->printHeader($prompt . ' (' . $current . ')', $opts); } $entries = $this->listDir($current); $choices = array_merge(['..'], $entries); $list_opts = $opts; if (!empty($opts['card'])) { $list_opts['card_title'] = $prompt . ' (' . $current . ')'; } $this->printList('', $choices, false, $list_opts); $scriptedValue = $opts['scripted_value'] ?? ''; if ($scripted) { if ($scriptedValue === '' || $scriptedValue === '1') { $scriptedValue = (string)$this->firstNonDotIndex($choices); } } $line = trim($this->readLine($this->decoratePrompt('Select', '', '', $opts + ['card_prompt' => false]), false, [ 'scripted' => $scripted, 'scripted_value' => (string)$scriptedValue, ])); $idx = (int)$line; if ($idx < 1 || $idx > count($choices)) continue; $picked = $choices[$idx - 1]; if ($picked === '..') { if ($scripted) { return $current; } $parent = dirname($current); $current = $parent ?: $current; continue; } $path = $current . DIRECTORY_SEPARATOR . $picked; if (is_dir($path)) { $current = $path; continue; } return $path; } } public function write(string $prompt, array $opts = []): string { $preferEditor = $opts['editor'] ?? true; $editor = getenv('EDITOR'); if ($preferEditor && $editor) { return \CLI::edit('', $opts['filename'] ?? 'notes.txt'); } $this->printHeader($prompt, $opts); echo "Finish with Ctrl+D (Unix) or Ctrl+Z then Enter (Windows).\n"; if (!empty($opts['scripted'])) { $scriptedValue = (string)($opts['scripted_value'] ?? "Line one\nLine two"); $lines = explode("\n", $scriptedValue); foreach ($lines as $line) { echo $line . PHP_EOL; } return $scriptedValue; } $lines = []; while (($line = fgets(STDIN)) !== false) { $lines[] = rtrim($line, "\r\n"); } return implode(PHP_EOL, $lines); } public function style(string $text, array $opts = []): string { return $this->style->apply($text, $opts); } public function join(array $pieces, array $opts = []): string { $axis = $opts['axis'] ?? 'vertical'; $gap = (int)($opts['gap'] ?? 0); $glue = $axis === 'horizontal' ? str_repeat(' ', max(1, $gap)) : str_repeat(PHP_EOL, max(1, $gap)); return implode($glue, $pieces); } private function decoratePrompt(string $prompt, string $default, string $placeholder, array $opts = []): string { $label = $prompt; if ($default !== '') $label .= ' [' . $default . ']'; if ($placeholder !== '') $label .= ' (' . $placeholder . ')'; $label .= ': '; if (!empty($opts['inline'])) { $label = '> ' . $label; } if (!empty($opts['accent'])) { $label = $this->style->apply($label, ['fg' => $opts['accent'], 'bold' => true]); } else if (!empty($opts['inline'])) { $label = $this->style->apply($label, ['fg' => '#a78bfa', 'bold' => true]); } $cardPrompt = !array_key_exists('card_prompt', $opts) ? true : (bool)$opts['card_prompt']; if (!empty($opts['card']) && $cardPrompt) { $label = $this->style->card($opts['title'] ?? 'Prompt', rtrim($label), [ 'padding' => 1, 'theme' => $opts['theme'] ?? 'lipgloss', 'border' => $opts['border'] ?? 'rounded', ]) . PHP_EOL; } return $label; } private function readLine(string $prompt, bool $silent = false, array $opts = []): string { if ($silent && $this->terminal->isTTY()) { $this->toggleEcho(false); } echo $prompt; if (!empty($opts['scripted'])) { $value = (string)($opts['scripted_value'] ?? ''); if ($silent && $value !== '') { echo str_repeat('*', min(12, strlen($value))); } else if ($value !== '') { echo $value; } echo PHP_EOL; if ($silent && $this->terminal->isTTY()) { $this->toggleEcho(true); } return $value; } $line = fgets(STDIN); $line = $line === false ? '' : rtrim($line, "\r\n"); if ($silent && $this->terminal->isTTY()) { $this->toggleEcho(true); echo PHP_EOL; } return $line; } private function toggleEcho(bool $enable): void { if (stripos(PHP_OS_FAMILY, 'Windows') !== false) { return; } $cmd = $enable ? 'stty echo' : 'stty -echo'; @shell_exec($cmd); } private function readPasswordWindows(string $prompt, array $opts = []): string { echo $this->decoratePrompt($prompt, '', '', $opts); $script = '$p = Read-Host -AsSecureString;' . '$b = [Runtime.InteropServices.Marshal]::SecureStringToBSTR($p);' . '[Runtime.InteropServices.Marshal]::PtrToStringAuto($b)'; $cmd = 'powershell -NoProfile -Command ' . escapeshellarg($script); $out = @shell_exec($cmd); $out = $out === null ? '' : $out; $out = rtrim($out, "\r\n"); echo PHP_EOL; return $out; } private function printList(string $title, array $items, bool $showTitle = true, array $opts = []): void { $content = ''; if ($showTitle && $title !== '') { $content .= $this->style->apply($title, ['fg' => '#93c5fd', 'bold' => true]) . "\n"; } foreach ($items as $idx => $item) { $num = $idx + 1; $numLabel = $this->style->apply('[' . $num . ']', ['fg' => '#94a3b8']); $content .= "  " . $numLabel . " " . $item . "\n"; } $content = rtrim($content, "\r\n"); if (!empty($opts['card'])) { $card_title = $opts['card_title'] ?? ($opts['title'] ?? 'Options'); echo $this->style->card($card_title, $content, [ 'padding' => 1, 'theme' => $opts['theme'] ?? 'lipgloss', 'border' => $opts['border'] ?? 'rounded', ]), PHP_EOL; } else { echo $content, PHP_EOL; } } private function printHeader(string $title, array $opts = []): void { if (!empty($opts['card'])) { echo $this->style->card($opts['title'] ?? 'Prompt', $title, [ 'padding' => 1, 'theme' => $opts['theme'] ?? 'lipgloss', 'border' => $opts['border'] ?? 'rounded', ]), PHP_EOL; } else { echo $this->style->apply($title, ['fg' => '#93c5fd', 'bold' => true]) . PHP_EOL; } } private function filterItems(array $items, string $query, bool $fuzzy): array { if ($query === '') return $items; $query = strtolower($query); $out = []; foreach ($items as $item) { $value = strtolower((string)$item); if ($fuzzy ? $this->fuzzyMatch($query, $value) : (strpos($value, $query) !== false)) { $out[] = $item; } } return $out; } private function fuzzyMatch(string $query, string $value): bool { $q = 0; $v = 0; while ($q < strlen($query) && $v < strlen($value)) { if ($query[$q] === $value[$v]) { $q++; } $v++; } return $q === strlen($query); } private function listDir(string $path): array { $entries = @scandir($path); if (!$entries) return []; $out = []; foreach ($entries as $entry) { if ($entry === '.' || $entry === '..') continue; $out[] = $entry; } return $out; } private function firstNonDotIndex(array $choices): int { foreach ($choices as $idx => $name) { if ($name !== '..') return $idx + 1; } return 1; } }class Style { private Terminal $terminal; private const ANSI16 = [ 'black' => 30, 'red' => 31, 'green' => 32, 'yellow' => 33, 'blue' => 34, 'magenta' => 35, 'cyan' => 36, 'white' => 37, 'gray' => 90, 'lightred' => 91, 'lightgreen' => 92, 'lightyellow' => 93, 'lightblue' => 94, 'lightmagenta' => 95, 'lightcyan' => 96, 'lightwhite' => 97, ]; public function __construct(?Terminal $terminal = null) { $this->terminal = $terminal ?? new Terminal(); } public function apply(string $text, array $opts = []): string { if (!$this->terminal->isTTY()) return $text; $codes = []; if (!empty($opts['bold'])) $codes[] = '1'; if (!empty($opts['dim'])) $codes[] = '2'; if (!empty($opts['italic'])) $codes[] = '3'; if (!empty($opts['underline'])) $codes[] = '4'; if (!empty($opts['fg'])) { $codes[] = $this->colorCode((string)$opts['fg'], false); } if (!empty($opts['bg'])) { $codes[] = $this->colorCode((string)$opts['bg'], true); } $prefix = $codes ? "\033[" . implode(';', $codes) . "m" : ''; $suffix = $codes ? "\033[0m" : ''; return $prefix . $text . $suffix; } public function pad(string $text, int $left = 0, int $right = 0, int $top = 0, int $bottom = 0): string { $lines = explode("\n", $text); $padded = []; $line_pad = str_repeat(' ', max(0, $left)); $right_pad = str_repeat(' ', max(0, $right)); foreach ($lines as $line) { $padded[] = $line_pad . $line . $right_pad; } $top_pad = array_fill(0, max(0, $top), ''); $bottom_pad = array_fill(0, max(0, $bottom), ''); return implode("\n", array_merge($top_pad, $padded, $bottom_pad)); } public function card(string $title, string $body, array $opts = []): string { $padding = (int)($opts['padding'] ?? 1); $border = $opts['border'] ?? true; $theme = $opts['theme'] ?? 'lipgloss'; $title_style = $opts['title_style'] ?? ($theme === 'lipgloss' ? ['bold' => true, 'fg' => '#a78bfa'] : ['bold' => true, 'fg' => '#93c5fd']); $border_style = $opts['border_style'] ?? ($theme === 'lipgloss' ? ['fg' => '#94a3b8'] : ['fg' => '#64748b']); $styled_title = $title !== '' ? $this->apply($title, $title_style) : ''; $content = $body; if ($styled_title !== '') { $content = $styled_title . "\n" . $body; } $content = str_replace(["\r\n", "\r"], "\n", $content); $content = $this->pad($content, $padding, $padding, $padding, $padding); if (!$border) return $content; $lines = explode("\n", $content); $max_len = 0; foreach ($lines as $line) { $len = $this->visibleWidth($line); if ($len > $max_len) $max_len = $len; } $border_chars = $this->borderChars($opts['border'] ?? 'rounded'); $top = $border_chars['tl'] . str_repeat($border_chars['h'], $max_len + 2) . $border_chars['tr']; $bottom = $border_chars['bl'] . str_repeat($border_chars['h'], $max_len + 2) . $border_chars['br']; $boxed = [$this->apply($top, $border_style)]; foreach ($lines as $line) { $pad = $max_len - $this->visibleWidth($line); $boxed[] = $this->apply($border_chars['v'] . ' ', $border_style) . $line . str_repeat(' ', $pad) . $this->apply(' ' . $border_chars['v'], $border_style); } $boxed[] = $this->apply($bottom, $border_style); return implode("\n", $boxed); } private function stripAnsi(string $text): string { return preg_replace('/\x1b\[[0-9;]*m/', '', $text); } private function visibleWidth(string $text): int { $clean = $this->stripAnsi($text); if (function_exists('mb_strwidth')) { return (int)mb_strwidth($clean); } if (function_exists('mb_strlen')) { return (int)mb_strlen($clean); } return strlen($clean); } private function borderChars(string $border): array { if ($border === 'rounded') { return [ 'tl' => '', 'tr' => '', 'bl' => '', 'br' => '', 'h' => '', 'v' => '', ]; } return [ 'tl' => '+', 'tr' => '+', 'bl' => '+', 'br' => '+', 'h' => '-', 'v' => '|', ]; } private function colorCode(string $value, bool $background): string { $profile = $this->terminal->colorProfile(); $value = strtolower($value); if ($profile === 'truecolor' && preg_match('/^#?([0-9a-f]{6})$/i', $value, $m)) { $hex = $m[1]; $r = hexdec(substr($hex, 0, 2)); $g = hexdec(substr($hex, 2, 2)); $b = hexdec(substr($hex, 4, 2)); return ($background ? '48' : '38') . ";2;$r;$g;$b"; } if (is_numeric($value) && $profile !== '16') { $idx = (int)$value; $idx = max(0, min(255, $idx)); return ($background ? '48' : '38') . ";5;$idx"; } if (isset(self::ANSI16[$value])) { $base = self::ANSI16[$value]; return (string)($background ? $base + 10 : $base); } return $background ? '49' : '39'; } }class Terminal { public function isTTY(): bool { $forced = $this->env('CORE_CLI_FORCE_TTY'); if ($forced === '1' || strtolower((string)$forced) === 'true') { return true; } if (function_exists('stream_isatty')) { return @stream_isatty(STDIN); } if (function_exists('posix_isatty')) { return @posix_isatty(STDIN); } return false; } public function colorProfile(): string { $forced = $this->env('CORE_CLI_COLOR'); if ($forced) return $forced; $colorterm = $this->env('COLORTERM'); if ($colorterm && stripos($colorterm, 'truecolor') !== false) return 'truecolor'; $term = $this->env('TERM'); if ($term && stripos($term, '256color') !== false) return '256'; return '16'; } public function width(): int { $cols = (int)trim((string)@shell_exec('tput cols')); return $cols > 0 ? $cols : 80; } public function height(): int { $rows = (int)trim((string)@shell_exec('tput lines')); return $rows > 0 ? $rows : 24; } private function env(string $key): ?string { $val = getenv($key); return $val === false ? null : $val; } }}
namespace Cache {interface Adapter { public function get($key); public function set($key,$value,$expire=0); public function delete($key); public function exists($key); public function flush(); public function inc($key,$value=1); public function dec($key,$value=1); public static function valid(); }class Files implements Adapter { protected $options; public static function valid(){ return true; } public function __construct($options=[]){ $this->options = (object) array_merge([ 'cache_dir' => sys_get_temp_dir().'/core_file_cache', ], $options); $this->options->cache_dir = rtrim($this->options->cache_dir,'/'); if (is_dir($this->options->cache_dir) && !is_writable($this->options->cache_dir)) { $this->options->cache_dir = sys_get_temp_dir().'/core_file_cache_'.getmypid(); } if(false===is_dir($this->options->cache_dir)) mkdir($this->options->cache_dir,0777,true); $this->options->cache_dir .= '/'; } public function get($key){ $cache_file_name = $this->options->cache_dir.$key.'.cache.php'; if(is_file($cache_file_name) && $data = @unserialize(file_get_contents($cache_file_name))){ if($data[0] && (time() > $data[0])) { unlink($cache_file_name); return null; } return $data[1]; } else { return null; } } public function set($key,$value,$expire=0){ $cache_file_name = $this->options->cache_dir.$key.'.cache.php'; file_put_contents($cache_file_name,serialize([$expire?time()+$expire:0,$value])); } public function delete($key){ $cache_file_name = $this->options->cache_dir.$key.'.cache.php'; if(is_file($cache_file_name)) unlink($cache_file_name); } public function exists($key){ $cache_file_name = $this->options->cache_dir.$key.'.cache.php'; if(false === is_file($cache_file_name)) return false; $raw = file_get_contents($cache_file_name); if ($raw === false) return false; $data = @unserialize($raw); if (!is_array($data) || count($data) < 2) { @unlink($cache_file_name); return false; } $expire = $data[0]; if($expire && $expire < time()){ unlink($cache_file_name); return false; } return true; } public function flush(){ exec('rm -f ' . $this->options->cache_dir . '*.cache.php'); } public function inc($key,$value=1){ if(null === ($current = $this->get($key))) $current = $value; else $current += $value; $this->set($key,$current); } public function dec($key,$value=1){ $this->inc($key,-abs($value)); } }class Memory implements Adapter { protected $memory = []; public static function valid(){ return true; } public function get($key){ if(isset($this->memory[$key])){ if($this->memory[$key][1] && (time() > $this->memory[$key][1])) { unset($this->memory[$key]); return null; } return $this->memory[$key][0]; } } public function set($key,$value,$expire=0){ $this->memory[$key] = [$value,$expire?time()+$expire:0]; } public function delete($key){ unset($this->memory[$key]); } public function exists($key){ return isset($this->memory[$key]) && (!$this->memory[$key][1] || (time() <= $this->memory[$key][1])); } public function flush(){ $this->memory = []; } public function inc($key,$value=1){ return isset($this->memory[$key]) ? $this->memory[$key][0] += $value : $this->memory[$key][0] = $value; } public function dec($key,$value=1){ $this->inc($key,-abs($value)); } }class Redis implements Adapter { protected $connection; protected $prefix; public static function valid() { return extension_loaded('redis'); } public function __construct($options = []) { $options = (object) array_merge([ 'host' => '127.0.0.1', 'port' => 6379, 'password' => null, 'prefix' => 'core:', 'database' => 0, 'timeout' => 2.0, ], $options); $this->prefix = $options->prefix; $this->connection = new \Redis(); $this->connection->connect($options->host, (int) $options->port, $options->timeout); if ($options->password) { $this->connection->auth($options->password); } if ($options->database) { $this->connection->select((int) $options->database); } } public function get($key) { $value = $this->connection->get($this->prefix . $key); if ($value === false) return null; $data = @unserialize($value); return $data === false && $value !== serialize(false) ? null : $data; } public function set($key, $value, $expire = 0) { $prefixed = $this->prefix . $key; $this->connection->set($prefixed, serialize($value)); if ($expire > 0) { $this->connection->expire($prefixed, $expire); } } public function delete($key) { $this->connection->del($this->prefix . $key); } public function exists($key) { return (bool) $this->connection->exists($this->prefix . $key); } public function flush() { if ($this->prefix) { $keys = $this->connection->keys($this->prefix . '*'); if ($keys) { $this->connection->del(...$keys); } } else { $this->connection->flushDB(); } } public function inc($key, $value = 1) { $prefixed = $this->prefix . $key; if (!$this->connection->exists($prefixed)) { $this->connection->set($prefixed, serialize($value)); return $value; } $current = $this->get($key); $current = (is_numeric($current) ? $current : 0) + $value; $this->connection->set($prefixed, serialize($current)); return $current; } public function dec($key, $value = 1) { $this->inc($key, -abs($value)); } }}
namespace Core {class Aliases { public static function register(): void { $map = [ 'Core' => '\\Core', 'Cache' => '\\Cache', 'Check' => '\\Check', 'CLI' => '\\CLI', 'CSV' => '\\CSV', 'Deferred' => '\\Deferred', 'Dictionary' => '\\Dictionary', 'Email' => '\\Email', 'Errors' => '\\Errors', 'Event' => '\\Event', 'File' => '\\File', 'Filter' => '\\Filter', 'Hash' => '\\Hash', 'HTTP' => '\\HTTP', 'Job' => '\\Job', 'Loader' => '\\Loader', 'Map' => '\\Map', 'Message' => '\\Message', 'Model' => '\\Model', 'Module' => '\\Module', 'Negotiation' => '\\Negotiation', 'Options' => '\\Options', 'Password' => '\\Password', 'Persistence' => '\\Persistence', 'Redirect' => '\\Redirect', 'Relation' => '\\Relation', 'Request' => '\\Request', 'Response' => '\\Response', 'Route' => '\\Route', 'Service' => '\\Service', 'Session' => '\\Session', 'Shell' => '\\Shell', 'SQL' => '\\SQL', 'Structure' => '\\Structure', 'Text' => '\\Text', 'Token' => '\\Token', 'URL' => '\\URL', 'View' => '\\View', 'Work' => '\\Work', 'ZIP' => '\\ZIP', ]; spl_autoload_register(callback: function($class) use ($map) { if (strpos($class, 'Core\\') !== 0) return false; $alias = substr($class, 5); if (!isset($map[$alias])) return false; $original = $map[$alias]; if (class_exists($original)) { if (!class_exists($class, false)) { class_alias($original, $class); } return true; } return false; }, throw: true, prepend: true); } }}
namespace Email {interface Driver { public function onInit($options); public function onSend(Envelope $envelope); }class Envelope { protected $uid, $to, $from, $cc, $bcc, $replyTo, $subject, $message, $contentType = 'text/html; charset="utf-8"', $attachments, $compiled_head, $compiled_body; public function __construct($email=null){ if ($email) { $email = (object)$email; if(isset($email->to)) $this->to($email->to); if(isset($email->from)) $this->from($email->from); if(isset($email->cc)) $this->cc($email->cc); if(isset($email->bcc)) $this->bcc($email->bcc); if(isset($email->replyTo)) $this->replyTo($email->replyTo); if(isset($email->subject)) $this->subject($email->subject); if(isset($email->message)) $this->message($email->message); if(isset($email->attachments)) $this->attach($email->attachments); } $this->uid = '_CORE_'.md5(uniqid(time())); } protected function add_emails(&$pool, $emails, $append=true){ $this->compiled_head = null; foreach ((array)$emails as $values) { foreach(preg_split('/\s*,\s*/',$values) as $value) { if(strpos($value,'<')!==false){ $value = str_replace('>','',$value); $parts = explode('<',$value,2); $name = trim(current($parts)); $email = trim(end($parts)); $address = "$name <{$email}>"; } else { $address = $value; } if ($append) $pool[] = $address; else $pool = $address; } } } public function from($value=null){ if ($value!==null && $value) { $this->add_emails($this->from, $value, false); } else if ($value===false) $this->from = ''; return $this->from; } public function to($value=null){ if ($value!==null && $value) { $this->add_emails($this->to, $value); } else if ($value===false) $this->to = []; return $this->to; } public function cc($value=null){ if ($value!==null && $value) { $this->add_emails($this->cc, $value); } else if ($value===false) $this->cc = []; return $this->cc; } public function bcc($value=null){ if ($value!==null && $value) { $this->add_emails($this->bcc, $value); } else if ($value===false) $this->bcc = []; return $this->bcc; } public function replyTo($value=null){ if ($value!==null && $value) { $this->add_emails($this->replyTo, $value, false); } else if ($value===false) $this->replyTo = ''; return $this->replyTo; } public function subject($value=null){ if ($value!==null && $value) { $this->compiled_head = null; $this->subject = $value; } else if ($value===false) $this->subject = ''; return $this->subject; } public function contentType($value=null){ if ($value!==null && $value) { if (empty($this->attachments)) $this->compiled_head = null; $this->compiled_body = null; $this->contentType = $value; } else if ($value===false) $this->contentType = ''; return $this->contentType; } public function message($value=null){ if ($value!==null && $value) { $this->compiled_body = null; $this->message = $value; } else if ($value===false) $this->message = ''; return $this->message; } public function attach($file){ $this->compiled_body = null; if (isset($file->content) || isset($file['content'])) { $this->attachments[] = $file; } else foreach ((array)$file as $curfile) { $this->attachments[] = $curfile; } } public function attachments($file=null){ if ($file!==null && $file) $this->attach($file); return $this->attachments ?: []; } public function head($recompile = false){ if ($recompile || (null === $this->compiled_head)){ $head = []; $head[] = "Subject: {$this->subject}"; if($this->from) $head[] = "From: {$this->from}"; if(is_array($this->to) && !empty($this->to)) $head[] = "To: " . implode(', ',$this->to); if(is_array($this->cc) && !empty($this->cc)) $head[] = "Cc: " . implode(', ',$this->cc); if(is_array($this->bcc) && !empty($this->bcc)) $head[] = "Bcc: " . implode(', ',$this->bcc); if($this->replyTo) $head[] = "Reply-To: {$this->replyTo}"; $head[] = "Content-Type: multipart/mixed; boundary=\"{$this->uid}\""; $head[] = 'MIME-Version: 1.0'; $head[] = ''; $this->compiled_head = implode("\r\n", $head); } return \Filter::with( 'core.email.source.head', $this->compiled_head); } public function body($recompile = false){ if ($recompile || (null === $this->compiled_body)){ $body = []; $body[] = "--{$this->uid}"; $body[] = "Content-Type: {$this->contentType}"; $body[] = "Content-Transfer-Encoding: quoted-printable"; $body[] = ''; $body[] = quoted_printable_encode($this->message ?? ''); $body[] = ''; if (!empty($this->attachments)) foreach ((array)$this->attachments as $file) { if (is_string($file)) { $name = basename($file); $data = file_get_contents($file); } else { $name = isset($file['name']) ? $file['name'] : 'untitled'; $data = isset($file['content']) ? $file['content'] : ''; } $body[] = "--{$this->uid}"; $body[] = "Content-Type: application/octet-stream; name=\"{$name}\""; $body[] = "Content-Transfer-Encoding: base64"; $body[] = "Content-Disposition: attachment; filename=\"{$name}\""; $body[] = ''; $body[] = chunk_split(base64_encode($data)); $body[] = ''; } $body[] = "--{$this->uid}"; $this->compiled_body = implode("\r\n", $body); } return \Filter::with( 'core.email.source.body', $this->compiled_body); } public function build(){ return \Filter::with( 'core.email.source', $this->head() . "\r\n" . $this->body() ); } }class Native implements Driver { public function onInit($options){} public function onSend(Envelope $envelope){ $results = []; $recipients = $envelope->to(); $envelope->to(false); foreach ($recipients as $to) { $results[$to] = mail($to,$envelope->subject(),$envelope->body(),$envelope->head()); } return $results; } }class Proxy implements Driver { protected $listener = 'core.email.proxy.send'; public function onInit($options){ if (!empty($options['hook'])) $this->listener = $options['hook']; } public function onSend(Envelope $envelope){ return array_reduce( (array) \Event::trigger($this->listener, $envelope), function($carry, $item) { if (is_bool($item)) $carry[] = $item; return $carry; }, []); } }class Smtp implements Driver { protected $socket, $host, $secure, $port, $lastCode, $lastMessage, $username, $password; public function onInit($options) { $options = (object)$options; $this->host = isset($options->host) ? $options->host : 'localhost'; $this->username = isset($options->username) ? $options->username : false; $this->secure = isset($options->secure) ? $options->secure : !empty($this->username); $this->port = isset($options->port) ? $options->port : ($this->secure ? 465 : 25); $this->password = isset($options->password) ? $options->password : false; } protected function connect(){ if ($this->socket) $this->close(); $url = ($this->secure ? 'tls' : 'tcp') ."://{$this->host}"; $this->socket = fsockopen( $url, $this->port, $errno, $errstr, 30 ); if (!$this->socket) throw new \Exception("Unable to connect to $url on port {$this->port}."); $this->lastMessage = ''; $this->lastCode = 0; } public function close(){ $this->socket && @fclose($this->socket); } protected function write($data, $nl = 1){ $payload = $data . str_repeat("\r\n",$nl); fwrite($this->socket, $payload); \Email::trigger("smtp.console",$payload); } protected function expectCode($code){ $this->lastMessage = ''; while (substr($this->lastMessage, 3, 1) != ' '){ $this->lastMessage = fgets($this->socket, 256); } $this->lastCode = 1 * substr($this->lastMessage, 0, 3); \Email::trigger("smtp.console",$this->lastMessage); if ($code != $this->lastCode) { throw new \Exception("Expected $code returned {$this->lastMessage}"); } return true; } protected function cleanAddr($email){ return preg_replace('((.*?)<([\w.@-]+)>(.*?))','$2',$email); } protected function SMTPmail($from,$to,$body){ try { $this->connect(); $this->expectCode(220); $this->write("EHLO {$this->host}"); $this->expectCode(250); if ($this->username){ $this->write("AUTH LOGIN"); $this->expectCode(334); $this->write(base64_encode($this->username)); $this->expectCode(334); $this->write(base64_encode($this->password)); $this->expectCode(235); } $from = $this->cleanAddr($from); $this->write("MAIL FROM: <{$from}>"); $this->expectCode(250); $to = $this->cleanAddr($to); $this->write("RCPT TO: <{$to}>"); $this->expectCode(250); $this->write("DATA"); $this->expectCode(354); $this->write($body); $this->write("."); $this->expectCode(250); $this->write("QUIT"); $this->close(); } catch (\Exception $e) { \Email::trigger('error',$e->getMessage()); return false; } return true; } public function onSend(Envelope $envelope){ $results = []; foreach ($envelope->to() as $to) { $results[$to] = $this->SMTPmail($envelope->from(), $to, $envelope->build()); } return $results; } }class Ses extends Smtp { public function onInit($options) { $options = (object)$options; $region = isset($options->region) ? $options->region : 'eu-west-1'; if (empty($options->username) || empty($options->password)) throw new \Exception("[core.email.ses] You must provide an Amazon SES SMTP username and password", 1); Smtp::onInit([ 'host' => "email-smtp.{$region}.amazonaws.com", 'secure' => true, 'port' => 465, 'username' => $options->username, 'password' => $options->password, ]); } public function onSend(Envelope $envelope){ if (!$envelope->from()) throw new \Exception("[core.email.ses] Amazon SES needs a registered `from` address", 1); return Smtp::onSend($envelope); } }}
namespace FileSystem {interface Adapter { public function exists($path); public function read($path); public function write($path, $data); public function append($path, $data); public function delete($path); public function move($old_path, $new_path); public function search($pattern, $recursive=true); }class Memory implements Adapter { protected $storage = []; public function exists($path){ return isset($this->storage[$path]); } public function read($path){ return $this->exists($path) ? $this->storage[$path] : false; } public function write($path, $data){ $this->storage[$path] = $data; } public function append($path, $data){ @$this->storage[$path] .= $data; } public function move($old, $new){ if($this->exists($old)){ $this->storage[$new] = $this->storage[$old]; unset($this->storage[$old]); return true; } else return false; } public function delete($path){ unset($this->storage[$path]); return true; } public function search($pattern, $recursive=true){ $results = []; $rx_pattern = '('.strtr($pattern,['.'=>'\.','*'=>'.*','?'=>'.']).')Ai'; foreach (array_keys($this->storage) as $path) { if (preg_match($rx_pattern,$path)) $results[] = $path; } return $results; } }class Native implements Adapter { protected $root; public function __construct(array $options = []) { $this->root = empty($options['root'])?'/':(rtrim($options['root'],'/').'/'); } public function exists($path){ return file_exists($this->realPath($path)); } public function read($path){ return $this->exists($path) ? file_get_contents($this->realPath($path)) : false; } public function write($path, $data){ $r_path = $this->realPath($path); if ( ! is_dir($r_dir = dirname($r_path)) ) @mkdir($r_dir,0775,true); return file_put_contents($r_path, $data); } public function append($path, $data){ return file_put_contents($this->realPath($path), $data, FILE_APPEND); } public function move($old, $new){ if($this->exists($old)){ return $this->write($new,$this->read($old)) && $this->delete($old); } else return false; } public function delete($path){ return $this->exists($path) ? unlink($this->realPath($path)) : false; } public function search($pattern, $recursive=true){ $results = []; $root_len = strlen($this->root); $rx_pattern = '('.strtr($pattern,['.'=>'\.','*'=>'.*','?'=>'.']).')Ai'; $stack = [$this->root]; while (!empty($stack)) { $dir = array_pop($stack); $items = @scandir($dir); if ($items === false) { continue; } foreach ($items as $item) { if ($item === '.' || $item === '..') { continue; } $path = rtrim($dir, '/\\') . DIRECTORY_SEPARATOR . $item; if (is_dir($path) && $recursive) { $stack[] = $path; } if (preg_match($rx_pattern, $path)) { $results[] = trim(substr($path, $root_len),'/'); } } } return $results; } protected function realPath($path){ return $this->root . $path; } }class ZIP implements Adapter { protected $path, $zipfile, $fileCache; public function __construct(array $options = []) { $this->path = empty($options['root'])?(tempnam(sys_get_temp_dir(), 'CFZ_').'.zip'):rtrim($options['root']); $this->zipfile = new \ZipArchive(); if ( !$this->zipfile->open($this->path, \ZipArchive::CREATE) ){ throw new \Exception("File::ZIP Cannot open or create ".$this->path); } } public function exists($path){ return false !== $this->zipfile->locateName($path); } public function read($path){ if (isset($this->fileCache[$path])) return $this->fileCache[$path]; return $this->exists($path) ? $this->zipfile->getFromName($path) : false; } public function write($path, $data){ $this->fileCache[$path] = $data; return $this->zipfile->addFromString($path, $data); } public function append($path, $data){ return $this->write($path, ($this->read($path) ?: '') . $data); } public function delete($path){ return $this->exists($path) ? $this->zipfile->deleteName($path) : false; } public function move($old, $new){ return $this->write($new,$this->read($old)) && $this->delete($old); } public function search($pattern, $recursive=true){ $results = []; $rx_pattern = '('.strtr($pattern,['.'=>'\.','*'=>'.*','?'=>'.']).')Ai'; for( $i = 0, $c = $this->zipfile->numFiles; $i < $c; $i++ ){ $stat = $this->zipfile->statIndex( $i ); if (preg_match($rx_pattern,$stat['name'])) $results[] = $stat['name']; } return $results; } }}
namespace View {interface Adapter { public function __construct($path=null, $options=[]); public function render($template,$data=[]); public static function exists($path); public static function addGlobal($key,$val); public static function addGlobals(array $defs); }class PHP implements Adapter { const EXTENSION = '.php'; protected static $templatePath, $globals = []; public function __construct($path=null,$options=[]){ self::$templatePath = ($path ? rtrim($path,'/') : __DIR__) . '/'; } public static function exists($path){ return is_file(self::$templatePath . $path . static::EXTENSION); } public static function addGlobal($key,$val){ self::$globals[$key] = $val; } public static function addGlobals(array $defs){ foreach ((array)$defs as $key=>$val) { self::$globals[$key] = $val; } } public function render($template, $data=[]){ $template_path = self::$templatePath . trim($template,'/') . static::EXTENSION; $sandbox = function() use ($template_path){ $data = $this->data ?? []; if (is_array($data)) { extract($data, EXTR_SKIP); } ob_start(); include($template_path); $__buffer__ = ob_get_contents(); ob_end_clean(); return $__buffer__; }; $context = new PHPContext( array_merge(self::$globals, $data), self::$templatePath ); return call_user_func($sandbox->bindTo($context, $context)); } } class PHPContext { protected $data = []; public function __construct($data=[], $path=null){ $this->data = $data; } public function partial($template, $vars=[]){ return \View::from($template,array_merge($this->data,$vars)); } public function __isset($n){ return true; } public function __unset($n){} public function __get($n){ return empty($this->data[$n]) ? '' : $this->data[$n]; } }}
namespace WebSocket {interface Adapter { public function send($channel, $data); public function broadcast($channel, $data); public static function valid(); }class Pusher implements Adapter { protected $options; public static function valid() { return extension_loaded('curl'); } public function __construct($options = []) { $this->options = (object) array_merge([ 'app_id' => \Options::get('websocket.pusher.app_id', ''), 'key' => \Options::get('websocket.pusher.key', ''), 'secret' => \Options::get('websocket.pusher.secret', ''), 'cluster' => \Options::get('websocket.pusher.cluster', 'mt1'), ], $options); } public function send($channel, $data) { return $this->trigger($channel, 'message', $data); } public function broadcast($channel, $data) { return $this->trigger($channel, 'broadcast', $data); } protected function trigger($channel, $event, $data) { $body = json_encode([ 'name' => $event, 'channel' => $channel, 'data' => json_encode($data), ]); $path = '/apps/' . $this->options->app_id . '/events'; $timestamp = time(); $params = [ 'auth_key' => $this->options->key, 'auth_timestamp' => $timestamp, 'auth_version' => '1.0', 'body_md5' => md5($body), ]; ksort($params); $queryString = http_build_query($params); $signString = "POST\n{$path}\n{$queryString}"; $signature = hash_hmac('sha256', $signString, $this->options->secret); $url = "https://api-{$this->options->cluster}.pusher.com{$path}?" . $queryString . '&auth_signature=' . $signature; $result = \HTTP::post($url, $body, ['Content-Type' => 'application/json']); return $result !== false; } }}
